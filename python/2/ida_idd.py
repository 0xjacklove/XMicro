# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: idd
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _ida_idd
else:
    import _ida_idd

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_idd.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range
class excvec_t(object):
    r"""
    Proxy of C++ qvector< exception_info_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> excvec_t
        __init__(self, x) -> excvec_t
        """
        _ida_idd.excvec_t_swiginit(self, _ida_idd.new_excvec_t(*args))
    __swig_destroy__ = _ida_idd.delete_excvec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""
        pop_back(self)
        """
        return _ida_idd.excvec_t_pop_back(self, *args)

    def size(self, *args):
        r"""
        size(self) -> size_t
        """
        return _ida_idd.excvec_t_size(self, *args)

    def empty(self, *args):
        r"""
        empty(self) -> bool
        """
        return _ida_idd.excvec_t_empty(self, *args)

    def at(self, *args):
        r"""
        at(self, _idx) -> exception_info_t
        """
        return _ida_idd.excvec_t_at(self, *args)

    def qclear(self, *args):
        r"""
        qclear(self)
        """
        return _ida_idd.excvec_t_qclear(self, *args)

    def clear(self, *args):
        r"""
        clear(self)
        """
        return _ida_idd.excvec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.excvec_t_resize(self, *args)

    def grow(self, *args):
        r"""
        grow(self, x=exception_info_t())
        """
        return _ida_idd.excvec_t_grow(self, *args)

    def capacity(self, *args):
        r"""
        capacity(self) -> size_t
        """
        return _ida_idd.excvec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""
        reserve(self, cnt)
        """
        return _ida_idd.excvec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""
        truncate(self)
        """
        return _ida_idd.excvec_t_truncate(self, *args)

    def swap(self, *args):
        r"""
        swap(self, r)
        """
        return _ida_idd.excvec_t_swap(self, *args)

    def extract(self, *args):
        r"""
        extract(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_extract(self, *args)

    def inject(self, *args):
        r"""
        inject(self, s, len)
        """
        return _ida_idd.excvec_t_inject(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> exception_info_t
        begin(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> exception_info_t
        end(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_end(self, *args)

    def insert(self, *args):
        r"""
        insert(self, it, x) -> exception_info_t
        """
        return _ida_idd.excvec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> exception_info_t
        erase(self, first, last) -> exception_info_t
        """
        return _ida_idd.excvec_t_erase(self, *args)

    def __len__(self, *args):
        r"""
        __len__(self) -> size_t
        """
        return _ida_idd.excvec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, i) -> exception_info_t
        """
        return _ida_idd.excvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, i, v)
        """
        return _ida_idd.excvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register excvec_t in _ida_idd:
_ida_idd.excvec_t_swigregister(excvec_t)

class procinfo_vec_t(object):
    r"""
    Proxy of C++ qvector< process_info_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> procinfo_vec_t
        __init__(self, x) -> procinfo_vec_t
        """
        _ida_idd.procinfo_vec_t_swiginit(self, _ida_idd.new_procinfo_vec_t(*args))
    __swig_destroy__ = _ida_idd.delete_procinfo_vec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""
        pop_back(self)
        """
        return _ida_idd.procinfo_vec_t_pop_back(self, *args)

    def size(self, *args):
        r"""
        size(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t_size(self, *args)

    def empty(self, *args):
        r"""
        empty(self) -> bool
        """
        return _ida_idd.procinfo_vec_t_empty(self, *args)

    def at(self, *args):
        r"""
        at(self, _idx) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_at(self, *args)

    def qclear(self, *args):
        r"""
        qclear(self)
        """
        return _ida_idd.procinfo_vec_t_qclear(self, *args)

    def clear(self, *args):
        r"""
        clear(self)
        """
        return _ida_idd.procinfo_vec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.procinfo_vec_t_resize(self, *args)

    def grow(self, *args):
        r"""
        grow(self, x=process_info_t())
        """
        return _ida_idd.procinfo_vec_t_grow(self, *args)

    def capacity(self, *args):
        r"""
        capacity(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""
        reserve(self, cnt)
        """
        return _ida_idd.procinfo_vec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""
        truncate(self)
        """
        return _ida_idd.procinfo_vec_t_truncate(self, *args)

    def swap(self, *args):
        r"""
        swap(self, r)
        """
        return _ida_idd.procinfo_vec_t_swap(self, *args)

    def extract(self, *args):
        r"""
        extract(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_extract(self, *args)

    def inject(self, *args):
        r"""
        inject(self, s, len)
        """
        return _ida_idd.procinfo_vec_t_inject(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> process_info_t
        begin(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> process_info_t
        end(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_end(self, *args)

    def insert(self, *args):
        r"""
        insert(self, it, x) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> process_info_t
        erase(self, first, last) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_erase(self, *args)

    def __len__(self, *args):
        r"""
        __len__(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, i) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, i, v)
        """
        return _ida_idd.procinfo_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register procinfo_vec_t in _ida_idd:
_ida_idd.procinfo_vec_t_swigregister(procinfo_vec_t)

class call_stack_t(object):
    r"""
    Proxy of C++ qvector< call_stack_info_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> call_stack_t
        __init__(self, x) -> call_stack_t
        """
        _ida_idd.call_stack_t_swiginit(self, _ida_idd.new_call_stack_t(*args))
    __swig_destroy__ = _ida_idd.delete_call_stack_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""
        pop_back(self)
        """
        return _ida_idd.call_stack_t_pop_back(self, *args)

    def size(self, *args):
        r"""
        size(self) -> size_t
        """
        return _ida_idd.call_stack_t_size(self, *args)

    def empty(self, *args):
        r"""
        empty(self) -> bool
        """
        return _ida_idd.call_stack_t_empty(self, *args)

    def at(self, *args):
        r"""
        at(self, _idx) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_at(self, *args)

    def qclear(self, *args):
        r"""
        qclear(self)
        """
        return _ida_idd.call_stack_t_qclear(self, *args)

    def clear(self, *args):
        r"""
        clear(self)
        """
        return _ida_idd.call_stack_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.call_stack_t_resize(self, *args)

    def grow(self, *args):
        r"""
        grow(self, x=call_stack_info_t())
        """
        return _ida_idd.call_stack_t_grow(self, *args)

    def capacity(self, *args):
        r"""
        capacity(self) -> size_t
        """
        return _ida_idd.call_stack_t_capacity(self, *args)

    def reserve(self, *args):
        r"""
        reserve(self, cnt)
        """
        return _ida_idd.call_stack_t_reserve(self, *args)

    def truncate(self, *args):
        r"""
        truncate(self)
        """
        return _ida_idd.call_stack_t_truncate(self, *args)

    def swap(self, *args):
        r"""
        swap(self, r)
        """
        return _ida_idd.call_stack_t_swap(self, *args)

    def extract(self, *args):
        r"""
        extract(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_extract(self, *args)

    def inject(self, *args):
        r"""
        inject(self, s, len)
        """
        return _ida_idd.call_stack_t_inject(self, *args)

    def __eq__(self, *args):
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_idd.call_stack_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_idd.call_stack_t___ne__(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> call_stack_info_t
        begin(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> call_stack_info_t
        end(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_end(self, *args)

    def insert(self, *args):
        r"""
        insert(self, it, x) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> call_stack_info_t
        erase(self, first, last) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_erase(self, *args)

    def find(self, *args):
        r"""
        find(self, x) -> call_stack_info_t
        find(self, x) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_find(self, *args)

    def has(self, *args):
        r"""
        has(self, x) -> bool
        """
        return _ida_idd.call_stack_t_has(self, *args)

    def add_unique(self, *args):
        r"""
        add_unique(self, x) -> bool
        """
        return _ida_idd.call_stack_t_add_unique(self, *args)

    def _del(self, *args):
        r"""
        _del(self, x) -> bool
        """
        return _ida_idd.call_stack_t__del(self, *args)

    def __len__(self, *args):
        r"""
        __len__(self) -> size_t
        """
        return _ida_idd.call_stack_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, i) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, i, v)
        """
        return _ida_idd.call_stack_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register call_stack_t in _ida_idd:
_ida_idd.call_stack_t_swigregister(call_stack_t)

class meminfo_vec_t(object):
    r"""
    Proxy of C++ qvector< memory_info_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> meminfo_vec_t
        __init__(self, x) -> meminfo_vec_t
        """
        _ida_idd.meminfo_vec_t_swiginit(self, _ida_idd.new_meminfo_vec_t(*args))
    __swig_destroy__ = _ida_idd.delete_meminfo_vec_t

    def push_back(self, *args):
        r"""
        push_back(self, x)
        push_back(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        r"""
        pop_back(self)
        """
        return _ida_idd.meminfo_vec_t_pop_back(self, *args)

    def size(self, *args):
        r"""
        size(self) -> size_t
        """
        return _ida_idd.meminfo_vec_t_size(self, *args)

    def empty(self, *args):
        r"""
        empty(self) -> bool
        """
        return _ida_idd.meminfo_vec_t_empty(self, *args)

    def at(self, *args):
        r"""
        at(self, _idx) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_at(self, *args)

    def qclear(self, *args):
        r"""
        qclear(self)
        """
        return _ida_idd.meminfo_vec_t_qclear(self, *args)

    def clear(self, *args):
        r"""
        clear(self)
        """
        return _ida_idd.meminfo_vec_t_clear(self, *args)

    def resize(self, *args):
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.meminfo_vec_t_resize(self, *args)

    def grow(self, *args):
        r"""
        grow(self, x=memory_info_t())
        """
        return _ida_idd.meminfo_vec_t_grow(self, *args)

    def capacity(self, *args):
        r"""
        capacity(self) -> size_t
        """
        return _ida_idd.meminfo_vec_t_capacity(self, *args)

    def reserve(self, *args):
        r"""
        reserve(self, cnt)
        """
        return _ida_idd.meminfo_vec_t_reserve(self, *args)

    def truncate(self, *args):
        r"""
        truncate(self)
        """
        return _ida_idd.meminfo_vec_t_truncate(self, *args)

    def swap(self, *args):
        r"""
        swap(self, r)
        """
        return _ida_idd.meminfo_vec_t_swap(self, *args)

    def extract(self, *args):
        r"""
        extract(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_extract(self, *args)

    def inject(self, *args):
        r"""
        inject(self, s, len)
        """
        return _ida_idd.meminfo_vec_t_inject(self, *args)

    def __eq__(self, *args):
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_idd.meminfo_vec_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_idd.meminfo_vec_t___ne__(self, *args)

    def begin(self, *args):
        r"""
        begin(self) -> memory_info_t
        begin(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_begin(self, *args)

    def end(self, *args):
        r"""
        end(self) -> memory_info_t
        end(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_end(self, *args)

    def insert(self, *args):
        r"""
        insert(self, it, x) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_insert(self, *args)

    def erase(self, *args):
        r"""
        erase(self, it) -> memory_info_t
        erase(self, first, last) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_erase(self, *args)

    def find(self, *args):
        r"""
        find(self, x) -> memory_info_t
        find(self, x) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_find(self, *args)

    def has(self, *args):
        r"""
        has(self, x) -> bool
        """
        return _ida_idd.meminfo_vec_t_has(self, *args)

    def add_unique(self, *args):
        r"""
        add_unique(self, x) -> bool
        """
        return _ida_idd.meminfo_vec_t_add_unique(self, *args)

    def _del(self, *args):
        r"""
        _del(self, x) -> bool
        """
        return _ida_idd.meminfo_vec_t__del(self, *args)

    def __len__(self, *args):
        r"""
        __len__(self) -> size_t
        """
        return _ida_idd.meminfo_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, i) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, i, v)
        """
        return _ida_idd.meminfo_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register meminfo_vec_t in _ida_idd:
_ida_idd.meminfo_vec_t_swigregister(meminfo_vec_t)

IDD_INTERFACE_VERSION = _ida_idd.IDD_INTERFACE_VERSION
"""
The IDD interface version number.
"""

NO_THREAD = _ida_idd.NO_THREAD
"""
No thread. in 'PROCESS_STARTED' this value can be used to specify that
the main thread has not been created. It will be initialized later by
a 'THREAD_STARTED' event.
"""

class process_info_t(object):
    r"""
    Proxy of C++ process_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pid = property(_ida_idd.process_info_t_pid_get, _ida_idd.process_info_t_pid_set)
    name = property(_ida_idd.process_info_t_name_get, _ida_idd.process_info_t_name_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> process_info_t
        """
        _ida_idd.process_info_t_swiginit(self, _ida_idd.new_process_info_t(*args))
    __swig_destroy__ = _ida_idd.delete_process_info_t

# Register process_info_t in _ida_idd:
_ida_idd.process_info_t_swigregister(process_info_t)

class debapp_attrs_t(object):
    r"""
    Proxy of C++ debapp_attrs_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cbsize = property(_ida_idd.debapp_attrs_t_cbsize_get, _ida_idd.debapp_attrs_t_cbsize_set)
    addrsize = property(_ida_idd.debapp_attrs_t_addrsize_get, _ida_idd.debapp_attrs_t_addrsize_set)
    platform = property(_ida_idd.debapp_attrs_t_platform_get, _ida_idd.debapp_attrs_t_platform_set)
    is_be = property(_ida_idd.debapp_attrs_t_is_be_get, _ida_idd.debapp_attrs_t_is_be_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> debapp_attrs_t
        """
        _ida_idd.debapp_attrs_t_swiginit(self, _ida_idd.new_debapp_attrs_t(*args))
    __swig_destroy__ = _ida_idd.delete_debapp_attrs_t

# Register debapp_attrs_t in _ida_idd:
_ida_idd.debapp_attrs_t_swigregister(debapp_attrs_t)
DEF_ADDRSIZE = _ida_idd.DEF_ADDRSIZE


class register_info_t(object):
    r"""
    Proxy of C++ register_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = property(_ida_idd.register_info_t_name_get, _ida_idd.register_info_t_name_set)
    flags = property(_ida_idd.register_info_t_flags_get, _ida_idd.register_info_t_flags_set)
    register_class = property(_ida_idd.register_info_t_register_class_get, _ida_idd.register_info_t_register_class_set)
    dtype = property(_ida_idd.register_info_t_dtype_get, _ida_idd.register_info_t_dtype_set)
    bit_strings = property(_ida_idd.register_info_t_bit_strings_get, _ida_idd.register_info_t_bit_strings_set)
    default_bit_strings_mask = property(_ida_idd.register_info_t_default_bit_strings_mask_get, _ida_idd.register_info_t_default_bit_strings_mask_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> register_info_t
        """
        _ida_idd.register_info_t_swiginit(self, _ida_idd.new_register_info_t(*args))
    __swig_destroy__ = _ida_idd.delete_register_info_t

# Register register_info_t in _ida_idd:
_ida_idd.register_info_t_swigregister(register_info_t)
REGISTER_READONLY = _ida_idd.REGISTER_READONLY
"""
the user can't modify the current value of this register
"""

REGISTER_IP = _ida_idd.REGISTER_IP
"""
instruction pointer
"""

REGISTER_SP = _ida_idd.REGISTER_SP
"""
stack pointer
"""

REGISTER_FP = _ida_idd.REGISTER_FP
"""
frame pointer
"""

REGISTER_ADDRESS = _ida_idd.REGISTER_ADDRESS
"""
may contain an address
"""

REGISTER_CS = _ida_idd.REGISTER_CS
"""
code segment
"""

REGISTER_SS = _ida_idd.REGISTER_SS
"""
stack segment
"""

REGISTER_NOLF = _ida_idd.REGISTER_NOLF
"""
allowing the next register to be displayed to its right (on the same
line)

displays this register without returning to the next line
"""

REGISTER_CUSTFMT = _ida_idd.REGISTER_CUSTFMT
"""
register should be displayed using a custom data format. the format
name is in bit_strings[0] the corresponding 'regval_t' will use
'bytevec_t'
"""


class memory_info_t(ida_range.range_t):
    r"""
    Proxy of C++ memory_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = property(_ida_idd.memory_info_t_name_get, _ida_idd.memory_info_t_name_set)
    sclass = property(_ida_idd.memory_info_t_sclass_get, _ida_idd.memory_info_t_sclass_set)
    sbase = property(_ida_idd.memory_info_t_sbase_get, _ida_idd.memory_info_t_sbase_set)
    bitness = property(_ida_idd.memory_info_t_bitness_get, _ida_idd.memory_info_t_bitness_set)
    perm = property(_ida_idd.memory_info_t_perm_get, _ida_idd.memory_info_t_perm_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> memory_info_t
        """
        _ida_idd.memory_info_t_swiginit(self, _ida_idd.new_memory_info_t(*args))

    def __eq__(self, *args):
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_idd.memory_info_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_idd.memory_info_t___ne__(self, *args)
    __swig_destroy__ = _ida_idd.delete_memory_info_t

# Register memory_info_t in _ida_idd:
_ida_idd.memory_info_t_swigregister(memory_info_t)

class scattered_segm_t(ida_range.range_t):
    r"""
    Proxy of C++ scattered_segm_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = property(_ida_idd.scattered_segm_t_name_get, _ida_idd.scattered_segm_t_name_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> scattered_segm_t
        """
        _ida_idd.scattered_segm_t_swiginit(self, _ida_idd.new_scattered_segm_t(*args))
    __swig_destroy__ = _ida_idd.delete_scattered_segm_t

# Register scattered_segm_t in _ida_idd:
_ida_idd.scattered_segm_t_swigregister(scattered_segm_t)

NO_EVENT = _ida_idd.NO_EVENT

PROCESS_STARTED = _ida_idd.PROCESS_STARTED

PROCESS_EXITED = _ida_idd.PROCESS_EXITED

THREAD_STARTED = _ida_idd.THREAD_STARTED

THREAD_EXITED = _ida_idd.THREAD_EXITED

BREAKPOINT = _ida_idd.BREAKPOINT

STEP = _ida_idd.STEP

EXCEPTION = _ida_idd.EXCEPTION

LIB_LOADED = _ida_idd.LIB_LOADED

LIB_UNLOADED = _ida_idd.LIB_UNLOADED

INFORMATION = _ida_idd.INFORMATION

PROCESS_ATTACHED = _ida_idd.PROCESS_ATTACHED

PROCESS_DETACHED = _ida_idd.PROCESS_DETACHED

PROCESS_SUSPENDED = _ida_idd.PROCESS_SUSPENDED

TRACE_FULL = _ida_idd.TRACE_FULL


def set_debug_event_code(*args):
    r"""
    set_debug_event_code(ev, id)
    """
    return _ida_idd.set_debug_event_code(*args)
class modinfo_t(object):
    r"""
    Proxy of C++ modinfo_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = property(_ida_idd.modinfo_t_name_get, _ida_idd.modinfo_t_name_set)
    base = property(_ida_idd.modinfo_t_base_get, _ida_idd.modinfo_t_base_set)
    size = property(_ida_idd.modinfo_t_size_get, _ida_idd.modinfo_t_size_set)
    rebase_to = property(_ida_idd.modinfo_t_rebase_to_get, _ida_idd.modinfo_t_rebase_to_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> modinfo_t
        """
        _ida_idd.modinfo_t_swiginit(self, _ida_idd.new_modinfo_t(*args))
    __swig_destroy__ = _ida_idd.delete_modinfo_t

# Register modinfo_t in _ida_idd:
_ida_idd.modinfo_t_swigregister(modinfo_t)

class bptaddr_t(object):
    r"""
    Proxy of C++ bptaddr_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    hea = property(_ida_idd.bptaddr_t_hea_get, _ida_idd.bptaddr_t_hea_set)
    kea = property(_ida_idd.bptaddr_t_kea_get, _ida_idd.bptaddr_t_kea_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> bptaddr_t
        """
        _ida_idd.bptaddr_t_swiginit(self, _ida_idd.new_bptaddr_t(*args))
    __swig_destroy__ = _ida_idd.delete_bptaddr_t

# Register bptaddr_t in _ida_idd:
_ida_idd.bptaddr_t_swigregister(bptaddr_t)

class excinfo_t(object):
    r"""
    Proxy of C++ excinfo_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = property(_ida_idd.excinfo_t_code_get, _ida_idd.excinfo_t_code_set)
    can_cont = property(_ida_idd.excinfo_t_can_cont_get, _ida_idd.excinfo_t_can_cont_set)
    ea = property(_ida_idd.excinfo_t_ea_get, _ida_idd.excinfo_t_ea_set)
    info = property(_ida_idd.excinfo_t_info_get, _ida_idd.excinfo_t_info_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> excinfo_t
        """
        _ida_idd.excinfo_t_swiginit(self, _ida_idd.new_excinfo_t(*args))
    __swig_destroy__ = _ida_idd.delete_excinfo_t

# Register excinfo_t in _ida_idd:
_ida_idd.excinfo_t_swigregister(excinfo_t)

class debug_event_t(object):
    r"""
    Proxy of C++ debug_event_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pid = property(_ida_idd.debug_event_t_pid_get, _ida_idd.debug_event_t_pid_set)
    tid = property(_ida_idd.debug_event_t_tid_get, _ida_idd.debug_event_t_tid_set)
    ea = property(_ida_idd.debug_event_t_ea_get, _ida_idd.debug_event_t_ea_set)
    handled = property(_ida_idd.debug_event_t_handled_get, _ida_idd.debug_event_t_handled_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> debug_event_t
        __init__(self, r) -> debug_event_t
        """
        _ida_idd.debug_event_t_swiginit(self, _ida_idd.new_debug_event_t(*args))
    __swig_destroy__ = _ida_idd.delete_debug_event_t

    def copy(self, *args):
        r"""
        copy(self, r) -> debug_event_t
        """
        return _ida_idd.debug_event_t_copy(self, *args)

    def clear(self, *args):
        r"""
        clear(self)
        """
        return _ida_idd.debug_event_t_clear(self, *args)

    def clear_all(self, *args):
        r"""
        clear_all(self)
        """
        return _ida_idd.debug_event_t_clear_all(self, *args)

    def eid(self, *args):
        r"""
        eid(self) -> event_id_t
        """
        return _ida_idd.debug_event_t_eid(self, *args)

    def set_eid(self, *args):
        r"""
        set_eid(self, id)
        """
        return _ida_idd.debug_event_t_set_eid(self, *args)

    def modinfo(self, *args):
        r"""
        modinfo(self) -> modinfo_t
        modinfo(self) -> modinfo_t
        """
        return _ida_idd.debug_event_t_modinfo(self, *args)

    def exit_code(self, *args):
        r"""
        exit_code(self) -> int const &
        """
        return _ida_idd.debug_event_t_exit_code(self, *args)

    def info(self, *args):
        r"""
        info(self) -> qstring
        info(self) -> qstring const &
        """
        return _ida_idd.debug_event_t_info(self, *args)

    def bpt(self, *args):
        r"""
        bpt(self) -> bptaddr_t
        bpt(self) -> bptaddr_t
        """
        return _ida_idd.debug_event_t_bpt(self, *args)

    def exc(self, *args):
        r"""
        exc(self) -> excinfo_t
        exc(self) -> excinfo_t
        """
        return _ida_idd.debug_event_t_exc(self, *args)

    def set_modinfo(self, *args):
        r"""
        set_modinfo(self, id) -> modinfo_t
        """
        return _ida_idd.debug_event_t_set_modinfo(self, *args)

    def set_exit_code(self, *args):
        r"""
        set_exit_code(self, id, code)
        """
        return _ida_idd.debug_event_t_set_exit_code(self, *args)

    def set_info(self, *args):
        r"""
        set_info(self, id) -> qstring &
        """
        return _ida_idd.debug_event_t_set_info(self, *args)

    def set_bpt(self, *args):
        r"""
        set_bpt(self) -> bptaddr_t
        """
        return _ida_idd.debug_event_t_set_bpt(self, *args)

    def set_exception(self, *args):
        r"""
        set_exception(self) -> excinfo_t
        """
        return _ida_idd.debug_event_t_set_exception(self, *args)

    def bpt_ea(self, *args):
        r"""
        bpt_ea(self) -> ea_t
        """
        return _ida_idd.debug_event_t_bpt_ea(self, *args)

# Register debug_event_t in _ida_idd:
_ida_idd.debug_event_t_swigregister(debug_event_t)

class exception_info_t(object):
    r"""
    Proxy of C++ exception_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = property(_ida_idd.exception_info_t_code_get, _ida_idd.exception_info_t_code_set)
    flags = property(_ida_idd.exception_info_t_flags_get, _ida_idd.exception_info_t_flags_set)

    def break_on(self, *args):
        r"""
        break_on(self) -> bool
        """
        return _ida_idd.exception_info_t_break_on(self, *args)

    def handle(self, *args):
        r"""
        handle(self) -> bool
        """
        return _ida_idd.exception_info_t_handle(self, *args)
    name = property(_ida_idd.exception_info_t_name_get, _ida_idd.exception_info_t_name_set)
    desc = property(_ida_idd.exception_info_t_desc_get, _ida_idd.exception_info_t_desc_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> exception_info_t
        __init__(self, _code, _flags, _name, _desc) -> exception_info_t
        """
        _ida_idd.exception_info_t_swiginit(self, _ida_idd.new_exception_info_t(*args))
    __swig_destroy__ = _ida_idd.delete_exception_info_t

# Register exception_info_t in _ida_idd:
_ida_idd.exception_info_t_swigregister(exception_info_t)
cvar = _ida_idd.cvar
BPT_WRITE = cvar.BPT_WRITE
BPT_READ = cvar.BPT_READ
BPT_RDWR = cvar.BPT_RDWR
BPT_SOFT = cvar.BPT_SOFT
BPT_EXEC = cvar.BPT_EXEC
BPT_DEFAULT = cvar.BPT_DEFAULT
EXC_BREAK = _ida_idd.EXC_BREAK
"""
break on the exception
"""

EXC_HANDLE = _ida_idd.EXC_HANDLE
"""
should be handled by the debugger?
"""

EXC_MSG = _ida_idd.EXC_MSG
"""
instead of a warning, log the exception to the output window
"""

EXC_SILENT = _ida_idd.EXC_SILENT
"""
do not warn or log to the output window
"""


class regval_t(object):
    r"""
    Proxy of C++ regval_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    rvtype = property(_ida_idd.regval_t_rvtype_get, _ida_idd.regval_t_rvtype_set)
    ival = property(_ida_idd.regval_t_ival_get, _ida_idd.regval_t_ival_set)
    fval = property(_ida_idd.regval_t_fval_get, _ida_idd.regval_t_fval_set)
    __swig_destroy__ = _ida_idd.delete_regval_t

    def __init__(self, *args):
        r"""
        __init__(self) -> regval_t
        __init__(self, r) -> regval_t
        """
        _ida_idd.regval_t_swiginit(self, _ida_idd.new_regval_t(*args))

    def clear(self, *args):
        r"""
        clear(self)
        """
        return _ida_idd.regval_t_clear(self, *args)

    def __eq__(self, *args):
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_idd.regval_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_idd.regval_t___ne__(self, *args)

    def swap(self, *args):
        r"""
        swap(self, r)
        """
        return _ida_idd.regval_t_swap(self, *args)

    def set_int(self, *args):
        r"""
        set_int(self, x)
        """
        return _ida_idd.regval_t_set_int(self, *args)

    def set_float(self, *args):
        r"""
        set_float(self, x)
        """
        return _ida_idd.regval_t_set_float(self, *args)

    def set_bytes(self, *args):
        r"""
        set_bytes(self, data, size)
        set_bytes(self, v)
        set_bytes(self) -> bytevec_t &
        """
        return _ida_idd.regval_t_set_bytes(self, *args)

    def set_unavailable(self, *args):
        r"""
        set_unavailable(self)
        """
        return _ida_idd.regval_t_set_unavailable(self, *args)

    def bytes(self, *args):
        r"""
        bytes(self) -> bytevec_t
        bytes(self) -> bytevec_t const &
        """
        return _ida_idd.regval_t_bytes(self, *args)

    def get_data(self, *args):
        r"""
        get_data(self)
        get_data(self) -> void const *
        """
        return _ida_idd.regval_t_get_data(self, *args)

    def get_data_size(self, *args):
        r"""
        get_data_size(self) -> size_t
        """
        return _ida_idd.regval_t_get_data_size(self, *args)

# Register regval_t in _ida_idd:
_ida_idd.regval_t_swigregister(regval_t)
RVT_INT = _ida_idd.RVT_INT
"""
integer
"""

RVT_FLOAT = _ida_idd.RVT_FLOAT
"""
floating point
"""

RVT_UNAVAILABLE = _ida_idd.RVT_UNAVAILABLE
"""
other values mean custom data type

unavailable
"""


class call_stack_info_t(object):
    r"""
    Proxy of C++ call_stack_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    callea = property(_ida_idd.call_stack_info_t_callea_get, _ida_idd.call_stack_info_t_callea_set)
    funcea = property(_ida_idd.call_stack_info_t_funcea_get, _ida_idd.call_stack_info_t_funcea_set)
    fp = property(_ida_idd.call_stack_info_t_fp_get, _ida_idd.call_stack_info_t_fp_set)
    funcok = property(_ida_idd.call_stack_info_t_funcok_get, _ida_idd.call_stack_info_t_funcok_set)

    def __eq__(self, *args):
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_idd.call_stack_info_t___eq__(self, *args)

    def __ne__(self, *args):
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_idd.call_stack_info_t___ne__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> call_stack_info_t
        """
        _ida_idd.call_stack_info_t_swiginit(self, _ida_idd.new_call_stack_info_t(*args))
    __swig_destroy__ = _ida_idd.delete_call_stack_info_t

# Register call_stack_info_t in _ida_idd:
_ida_idd.call_stack_info_t_swigregister(call_stack_info_t)


def dbg_appcall(*args):
    r"""
    dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t


    Call a function from the debugged application.
    
    @param retval (C++: idc_value_t  *)
    @param func_ea: address to call (C++: ea_t)
    @param tid: thread to use.  NO_THREAD  means to use the current thread
                (C++: thid_t)
    @param ptif: pointer to type of the function to call (C++: const
                 tinfo_t  *)
    @param argv: array of arguments (C++: idc_value_t  *)
    @param argnum: number of actual arguments (C++: size_t)
    @return: eOk  if successful, otherwise an error code
    """
    return _ida_idd.dbg_appcall(*args)

def cleanup_appcall(*args):
    r"""
    cleanup_appcall(tid) -> error_t


    Cleanup after manual appcall.
    
    @param tid: thread to use.  NO_THREAD  means to use the current thread
                The application state is restored as it was before calling
                the last appcall(). Nested appcalls are supported. (C++:
                thid_t)
    @return: eOk  if successful, otherwise an error code
    """
    return _ida_idd.cleanup_appcall(*args)
class thread_name_t(object):
    r"""
    Proxy of C++ thread_name_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    tid = property(_ida_idd.thread_name_t_tid_get, _ida_idd.thread_name_t_tid_set)
    name = property(_ida_idd.thread_name_t_name_get, _ida_idd.thread_name_t_name_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> thread_name_t
        """
        _ida_idd.thread_name_t_swiginit(self, _ida_idd.new_thread_name_t(*args))
    __swig_destroy__ = _ida_idd.delete_thread_name_t

# Register thread_name_t in _ida_idd:
_ida_idd.thread_name_t_swigregister(thread_name_t)

RESMOD_NONE = _ida_idd.RESMOD_NONE

RESMOD_INTO = _ida_idd.RESMOD_INTO

RESMOD_OVER = _ida_idd.RESMOD_OVER

RESMOD_OUT = _ida_idd.RESMOD_OUT

RESMOD_SRCINTO = _ida_idd.RESMOD_SRCINTO

RESMOD_SRCOVER = _ida_idd.RESMOD_SRCOVER

RESMOD_SRCOUT = _ida_idd.RESMOD_SRCOUT

RESMOD_USER = _ida_idd.RESMOD_USER

RESMOD_HANDLE = _ida_idd.RESMOD_HANDLE

RESMOD_MAX = _ida_idd.RESMOD_MAX

STEP_TRACE = _ida_idd.STEP_TRACE

INSN_TRACE = _ida_idd.INSN_TRACE

FUNC_TRACE = _ida_idd.FUNC_TRACE

BBLK_TRACE = _ida_idd.BBLK_TRACE

DRC_EVENTS = _ida_idd.DRC_EVENTS

DRC_CRC = _ida_idd.DRC_CRC

DRC_OK = _ida_idd.DRC_OK

DRC_NONE = _ida_idd.DRC_NONE

DRC_FAILED = _ida_idd.DRC_FAILED

DRC_NETERR = _ida_idd.DRC_NETERR

DRC_NOFILE = _ida_idd.DRC_NOFILE

DRC_IDBSEG = _ida_idd.DRC_IDBSEG

DRC_NOPROC = _ida_idd.DRC_NOPROC

DRC_NOCHG = _ida_idd.DRC_NOCHG

DRC_ERROR = _ida_idd.DRC_ERROR

RQ_MASKING = _ida_idd.RQ_MASKING

RQ_SUSPEND = _ida_idd.RQ_SUSPEND

RQ_NOSUSP = _ida_idd.RQ_NOSUSP

RQ_IGNWERR = _ida_idd.RQ_IGNWERR

RQ_SILENT = _ida_idd.RQ_SILENT

RQ_VERBOSE = _ida_idd.RQ_VERBOSE

RQ_SWSCREEN = _ida_idd.RQ_SWSCREEN

RQ__NOTHRRF = _ida_idd.RQ__NOTHRRF

RQ_PROCEXIT = _ida_idd.RQ_PROCEXIT

RQ_IDAIDLE = _ida_idd.RQ_IDAIDLE

RQ_SUSPRUN = _ida_idd.RQ_SUSPRUN

RQ_RESUME = _ida_idd.RQ_RESUME

RQ_RESMOD = _ida_idd.RQ_RESMOD

RQ_RESMOD_SHIFT = _ida_idd.RQ_RESMOD_SHIFT


def dbg_get_registers(*args):
    r"""
    dbg_get_registers() -> PyObject *


    This function returns the register definition from the currently loaded debugger.
    Basically, it returns an array of structure similar to to idd.hpp / register_info_t
    @return:
        None if no debugger is loaded
        tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
        The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)
    """
    return _ida_idd.dbg_get_registers(*args)

def dbg_get_thread_sreg_base(*args):
    r"""
    dbg_get_thread_sreg_base(tid, sreg_value) -> PyObject *


    Returns the segment register base value
    @param tid: thread id
    @param sreg_value: segment register (selector) value
    @return:
        - The base as an 'ea'
        - Or None on failure
    """
    return _ida_idd.dbg_get_thread_sreg_base(*args)

def dbg_read_memory(*args):
    r"""
    dbg_read_memory(ea, sz) -> PyObject *


    Reads from the debugee's memory at the specified ea
    @return:
        - The read buffer (as a string)
        - Or None on failure
    """
    return _ida_idd.dbg_read_memory(*args)

def dbg_write_memory(*args):
    r"""
    dbg_write_memory(ea, buf) -> PyObject *


    Writes a buffer to the debugee's memory
    @return: Boolean
    """
    return _ida_idd.dbg_write_memory(*args)

def dbg_get_name(*args):
    r"""
    dbg_get_name() -> PyObject *


    This function returns the current debugger's name.
    @return: Debugger name or None if no debugger is active
    """
    return _ida_idd.dbg_get_name(*args)

def dbg_get_memory_info(*args):
    r"""
    dbg_get_memory_info() -> PyObject *


    This function returns the memory configuration of a debugged process.
    @return:
        None if no debugger is active
        tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)
    """
    return _ida_idd.dbg_get_memory_info(*args)

def appcall(*args):
    r"""
    appcall(func_ea, tid, _type_or_none, _fields, arg_list) -> PyObject *
    """
    return _ida_idd.appcall(*args)

def get_event_module_name(*args):
    r"""
    get_event_module_name(ev) -> str
    """
    return _ida_idd.get_event_module_name(*args)

def get_event_module_base(*args):
    r"""
    get_event_module_base(ev) -> ea_t
    """
    return _ida_idd.get_event_module_base(*args)

def get_event_module_size(*args):
    r"""
    get_event_module_size(ev) -> asize_t
    """
    return _ida_idd.get_event_module_size(*args)

def get_event_exc_info(*args):
    r"""
    get_event_exc_info(ev) -> str
    """
    return _ida_idd.get_event_exc_info(*args)

def get_event_info(*args):
    r"""
    get_event_info(ev) -> str
    """
    return _ida_idd.get_event_info(*args)

def get_event_bpt_hea(*args):
    r"""
    get_event_bpt_hea(ev) -> ea_t
    """
    return _ida_idd.get_event_bpt_hea(*args)

def get_event_exc_code(*args):
    r"""
    get_event_exc_code(ev) -> uint
    """
    return _ida_idd.get_event_exc_code(*args)

def get_event_exc_ea(*args):
    r"""
    get_event_exc_ea(ev) -> ea_t
    """
    return _ida_idd.get_event_exc_ea(*args)

def can_exc_continue(*args):
    r"""
    can_exc_continue(ev) -> bool
    """
    return _ida_idd.can_exc_continue(*args)

#<pycode(py_idd)>
NO_PROCESS = 0xFFFFFFFF
"""
No process.
"""
NO_THREAD  = 0
"""
No thread. in 'PROCESS_STARTED' this value can be used to specify that
the main thread has not been created. It will be initialized later by
a 'THREAD_STARTED' event.
"""

import types
import _ida_idaapi
import _ida_dbg
import _ida_typeinf
import _ida_name
import _ida_bytes
import _ida_ida
import ida_idaapi
import ida_typeinf

dbg_can_query = _ida_dbg.dbg_can_query

# -----------------------------------------------------------------------
class Appcall_array__(object):
    """
    This class is used with Appcall.array() method
    """
    def __init__(self, tp):
        self.__type = tp

    def pack(self, L):
        """
        Packs a list or tuple into a byref buffer
        """
        t = type(L)
        if not (t == list or t == tuple):
            raise ValueError("Either a list or a tuple must be passed")
        self.__size = len(L)
        if self.__size == 1:
            self.__typedobj = Appcall__.typedobj(self.__type + ";")
        else:
            self.__typedobj = Appcall__.typedobj("%s x[%d];" % (self.__type, self.__size))
# Now store the object in a string buffer
        ok, buf = self.__typedobj.store(L)
        if ok:
            return Appcall__.byref(buf)
        else:
            return None

    def try_to_convert_to_list(self, obj):
        """
        Is this object a list? We check for the existance of attribute zero and attribute self.size-1
        """
        if not (hasattr(obj, "0") and hasattr(obj, str(self.__size-1))):
            return obj
# at this point, we are sure we have an "idc list"
# let us convert to a Python list
        return [getattr(obj, str(x)) for x in range(0, self.__size)]

    def unpack(self, buf, as_list=True):
        """
        Unpacks an array back into a list or an object
        """
# take the value from the special ref object
        if isinstance(buf, ida_idaapi.PyIdc_cvt_refclass__):
            buf = buf.value

# we can only unpack from strings
        if type(buf) != bytes:
            raise ValueError("Cannot unpack this type!")
# now unpack
        ok, obj = self.__typedobj.retrieve(buf)
        if not ok:
            raise ValueError("Failed while unpacking!")
        if not as_list:
            return obj
        return self.try_to_convert_to_list(obj)


# -----------------------------------------------------------------------
# Wrapper class for the appcall()
class Appcall_callable__(object):
    """
    Helper class to issue appcalls using a natural syntax:
      appcall.FunctionNameInTheDatabase(arguments, ....)
    or
      appcall["Function@8"](arguments, ...)
    or
      f8 = appcall["Function@8"]
      f8(arg1, arg2, ...)
    or
      o = appcall.obj()
      i = byref(5)
      appcall.funcname(arg1, i, "hello", o)
    """
    def __init__(self, ea, tinfo_or_typestr = None, fields = None):
        """
        Initializes an appcall with a given function ea
        """
        self.__ea      = ea
        self.__tif     = None
        self.__type    = None
        self.__fields  = None
        self.__options = None # Appcall options
        self.__timeout = None # Appcall timeout

        if tinfo_or_typestr:
          if isinstance(tinfo_or_typestr, ida_idaapi.string_types):
# a type string? assume (typestr, fields), try to deserialize
            tif = ida_typeinf.tinfo_t()
            if not tif.deserialize(None, tinfo_or_typestr, fields):
              raise ValueError("Could not deserialize type string")
          else:
            if not isinstance(tinfo_or_typestr, ida_typeinf.tinfo_t):
              raise ValueError("Invalid argument 'tinfo_or_typestr'")
            tif = tinfo_or_typestr
          self.__tif = tif
          (self.__type, self.__fields, _) = tif.serialize()

    def __get_timeout(self):
        return self.__timeout

    def __set_timeout(self, v):
        self.__timeout = v

    timeout = property(__get_timeout, __set_timeout)
    """
    An Appcall instance can change its timeout value with this attribute
    """

    def __get_options(self):
        return self.__options if self.__options != None else Appcall__.get_appcall_options()

    def __set_options(self, v):
        if self.timeout:
# If timeout value is set, then put the timeout flag and encode the timeout value
            v |= Appcall__.APPCALL_TIMEOUT | (self.timeout << 16)
        else:
# Timeout is not set, then clear the timeout flag
            v &= ~Appcall__.APPCALL_TIMEOUT

        self.__options = v

    options = property(__get_options, __set_options)
    """
    Sets the Appcall options locally to this Appcall instance
    """

    def __call__(self, *args):
        """
        Make object callable. We redirect execution to idaapi.appcall()
        """
        if self.ea is None:
            raise ValueError("Object not callable!")

# convert arguments to a list
        arg_list = list(args)

# Save appcall options and set new global options
        old_opt = Appcall__.get_appcall_options()
        Appcall__.set_appcall_options(self.options)

# Do the Appcall (use the wrapped version)
        try:
            return _ida_idd.appcall(
                self.ea,
                _ida_dbg.get_current_thread(),
                self.type,
                self.fields,
                arg_list)
        finally:
# Restore appcall options
            Appcall__.set_appcall_options(old_opt)

    def __get_ea(self):
        return self.__ea

    def __set_ea(self, val):
        self.__ea = val

    ea = property(__get_ea, __set_ea)
    """
    Returns or sets the EA associated with this object
    """

    def __get_tif(self):
        return self.__tif

    tif = property(__get_tif)
    """
    Returns the tinfo_t object
    """

    def __get_size(self):
        if self.__type == None:
            return -1
        r = _ida_typeinf.calc_type_size(None, self.__type)
        if not r:
            return -1
        return r

    size = property(__get_size)
    """
    Returns the size of the type
    """

    def __get_type(self):
        return self.__type

    type = property(__get_type)
    """
    Returns the typestring
    """

    def __get_fields(self):
        return self.__fields

    fields = property(__get_fields)
    """
    Returns the field names
    """


    def retrieve(self, src=None, flags=0):
        """
        Unpacks a typed object from the database if an ea is given or from a string if a string was passed
        @param src: the address of the object or a string
        @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
        """

# Nothing passed? Take the address and unpack from the database
        if src is None:
            src = self.ea

        if type(src) == bytes:
            return _ida_typeinf.unpack_object_from_bv(None, self.type, self.fields, src, flags)
        else:
            return _ida_typeinf.unpack_object_from_idb(None, self.type, self.fields, src, flags)

    def store(self, obj, dest_ea=None, base_ea=0, flags=0):
        """
        Packs an object into a given ea if provided or into a string if no address was passed.
        @param obj: The object to pack
        @param dest_ea: If packing to idb this will be the store location
        @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers

        @return:
            - If packing to a string then a Tuple(Boolean, packed_string or error code)
            - If packing to the database then a return code is returned (0 is success)
        """

# no ea passed? thus pack to a string
        if dest_ea is None:
            return _ida_typeinf.pack_object_to_bv(obj,
                                             None,
                                             self.type,
                                             self.fields,
                                             base_ea,
                                             flags)
        else:
            return _ida_typeinf.pack_object_to_idb(obj,
                                              None,
                                              self.type,
                                              self.fields,
                                              dest_ea,
                                              flags)

# -----------------------------------------------------------------------
class Appcall_consts__(object):
    """
    Helper class used by Appcall.Consts attribute
    It is used to retrieve constants via attribute access
    """
    def __init__(self, default=None):
        self.__default = default

    def __getattr__(self, attr):
        v = Appcall__.valueof(attr, self.__default)
        if v is None:
            raise ValueError("No constant with name " + attr)
        return v

# -----------------------------------------------------------------------
class Appcall__(object):
    APPCALL_MANUAL = 0x1
    """
    Only set up the appcall, do not run it.
    you should call CleanupAppcall() when finished
    """

    APPCALL_DEBEV  = 0x2
    """
    Return debug event information
    If this bit is set, exceptions during appcall
    will generate idc exceptions with full
    information about the exception
    """

    APPCALL_TIMEOUT = 0x4
    """
    Appcall with timeout
    The timeout value in milliseconds is specified
    in the high 2 bytes of the 'options' argument:
    If timed out, errbuf will contain "timeout".
    """

    __name__ = "Appcall__"

    def __init__(self):
        self.__consts = Appcall_consts__()

    def __get_consts(self):
        return self.__consts

    Consts = property(__get_consts)
    """
    Use Appcall.Consts.CONST_NAME to access constants
    """

    @staticmethod
    def __name_or_ea(name_or_ea):
        """
        Function that accepts a name or an ea and checks if the address is enabled.
        If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
        @return:
            - Returns the resolved EA or
            - Raises an exception if the address is not enabled
        """

# a string? try to resolve it
        if type(name_or_ea) in ida_idaapi.string_types:
            ea = _ida_name.get_name_ea(_ida_idaapi.BADADDR, name_or_ea)
        else:
            ea = name_or_ea
# could not resolve name or invalid address?
        if ea == _ida_idaapi.BADADDR or not _ida_bytes.is_mapped(ea):
            raise ValueError("Undefined function " + name_or_ea)
        return ea

    @staticmethod
    def __typedecl_or_tinfo(typedecl_or_tinfo, flags = None):
        """
        Function that accepts a tinfo_t object or type declaration as a string
        If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
        @return:
            - Returns the tinfo_t object
            - Raises an exception if the declaration cannot be parsed
        """

# a string? try to parse it
        if isinstance(typedecl_or_tinfo, ida_idaapi.string_types):
          if flags is None:
              flags = ida_typeinf.PT_SIL|ida_typeinf.PT_NDC|ida_typeinf.PT_TYP
          tif = ida_typeinf.tinfo_t()
          if ida_typeinf.parse_decl(tif, None, typedecl_or_tinfo, flags) == None:
            raise ValueError("Could not parse type: " + typedecl_or_tinfo)
        else:
            if not isinstance(typedecl_or_tinfo, ida_typeinf.tinfo_t):
              raise ValueError("Invalid argument 'typedecl_or_tinfo'")
            tif = typedecl_or_tinfo
        return tif

    @staticmethod
    def proto(name_or_ea, proto_or_tinfo, flags = None):
        """
        Allows you to instantiate an appcall (callable object) with the desired prototype
        @param name_or_ea: The name of the function (will be resolved with LocByName())
        @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
        @return:
            - On failure it raises an exception if the prototype could not be parsed
              or the address is not resolvable
            - Returns a callbable Appcall instance with the given prototypes and flags
        """

# resolve and raise exception on error
        ea = Appcall__.__name_or_ea(name_or_ea)

# parse the type if it is given as (prototype, flags)
        tif = Appcall__.__typedecl_or_tinfo(proto_or_tinfo, flags)

# Return the callable method with type info
        return Appcall_callable__(ea, tif)

    def __getattr__(self, name_or_ea):
        """
        Allows you to call functions as if they were member functions (by returning a callable object)
        """
# resolve and raise exception on error
        ea = self.__name_or_ea(name_or_ea)
        if ea == _ida_idaapi.BADADDR:
            raise ValueError("Undefined function " + name)
# Return the callable method
        return Appcall_callable__(ea)

    def __getitem__(self, idx):
        """
        Use self[func_name] syntax if the function name contains invalid characters for an attribute name
        See __getattr___
        """
        return self.__getattr__(idx)

    @staticmethod
    def valueof(name, default=0):
        """
        Returns the numeric value of a given name string.
        If the name could not be resolved then the default value will be returned
        """
        t, v = _ida_name.get_name_value(_ida_idaapi.BADADDR, name)
        if t == 0: # NT_NONE
          v = default
        return v

    @staticmethod
    def int64(v):
        """
        Whenever a 64bit number is needed use this method to construct an object
        """
        return ida_idaapi.PyIdc_cvt_int64__(v)

    @staticmethod
    def byref(val):
        """
        Method to create references to immutable objects
        Currently we support references to int/strings
        Objects need not be passed by reference (this will be done automatically)
        """
        return ida_idaapi.PyIdc_cvt_refclass__(val)

    @staticmethod
    def buffer(str = None, size = 0, fill="\x00"):
        """
        Creates a string buffer. The returned value (r) will be a byref object.
        Use r.value to get the contents and r.size to get the buffer's size
        """
        if str is None:
            str = ""
        left = size - len(str)
        if left > 0:
            str = str + (fill * left)
        r = Appcall__.byref(str)
        r.size = size
        return r

    @staticmethod
    def obj(**kwds):
        """
        Returns an empty object or objects with attributes as passed via its keywords arguments
        """
        return ida_idaapi.object_t(**kwds)

    @staticmethod
    def cstr(val):
        return ida_idaapi.as_cstr(val)

    @staticmethod
    def UTF16(s):
        return ida_idaapi.as_UTF16(s)
    unicode = UTF16

    @staticmethod
    def array(type_name):
        """
        Defines an array type. Later you need to pack() / unpack()
        """
        return Appcall_array__(type_name)

    @staticmethod
    def typedobj(typedecl_or_tinfo, ea=None):
        """
        Returns an appcall object for a type (can be given as tinfo_t object or
        as a string declaration)
        One can then use retrieve() member method
        @param ea: Optional parameter that later can be used to retrieve the type
        @return: Appcall object or raises ValueError exception
        """
# parse the type if it is given as string
        tif = Appcall__.__typedecl_or_tinfo(typedecl_or_tinfo)
# Return the callable method with type info
        return Appcall_callable__(ea, tif)

    @staticmethod
    def set_appcall_options(opt):
        """
        Method to change the Appcall options globally (not per Appcall)
        """
        old_opt = Appcall__.get_appcall_options()
        _ida_ida.cvar.inf.appcall_options = opt
        return old_opt

    @staticmethod
    def get_appcall_options():
        """
        Return the global Appcall options
        """
        return _ida_ida.cvar.inf.appcall_options

    @staticmethod
    def cleanup_appcall(tid = 0):
        """
        Equivalent to IDC's CleanupAppcall()
        """
        return _ida_idd.cleanup_appcall(tid)

Appcall = Appcall__()
#</pycode(py_idd)>


if _BC695:
    PROCESS_NO_THREAD=NO_THREAD



