# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: dbg
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_dbg
else:
    import _ida_dbg

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_dbg.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_idd
class bpt_vec_t(object):
    r"""
    Proxy of C++ qvector< bpt_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> bpt_vec_t
        __init__(self, x) -> bpt_vec_t
        """
        _ida_dbg.bpt_vec_t_swiginit(self, _ida_dbg.new_bpt_vec_t(*args))
    __swig_destroy__ = _ida_dbg.delete_bpt_vec_t

    def push_back(self, *args) -> "bpt_t &":
        r"""
        push_back(self, x)
        push_back(self) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.bpt_vec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.bpt_vec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.bpt_vec_t_empty(self, *args)

    def at(self, *args) -> "bpt_t const &":
        r"""
        at(self, _idx) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.bpt_vec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.bpt_vec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_dbg.bpt_vec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, x=bpt_t())
        """
        return _ida_dbg.bpt_vec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.bpt_vec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""
        reserve(self, cnt)
        """
        return _ida_dbg.bpt_vec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.bpt_vec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""
        swap(self, r)
        """
        return _ida_dbg.bpt_vec_t_swap(self, *args)

    def extract(self, *args) -> "bpt_t *":
        r"""
        extract(self) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""
        inject(self, s, len)
        """
        return _ida_dbg.bpt_vec_t_inject(self, *args)

    def begin(self, *args) -> "qvector< bpt_t >::const_iterator":
        r"""
        begin(self) -> bpt_t
        begin(self) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_begin(self, *args)

    def end(self, *args) -> "qvector< bpt_t >::const_iterator":
        r"""
        end(self) -> bpt_t
        end(self) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_end(self, *args)

    def insert(self, *args) -> "qvector< bpt_t >::iterator":
        r"""
        insert(self, it, x) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< bpt_t >::iterator":
        r"""
        erase(self, it) -> bpt_t
        erase(self, first, last) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.bpt_vec_t___len__(self, *args)

    def __getitem__(self, *args) -> "bpt_t const &":
        r"""
        __getitem__(self, i) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, i, v)
        """
        return _ida_dbg.bpt_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register bpt_vec_t in _ida_dbg:
_ida_dbg.bpt_vec_t_swigregister(bpt_vec_t)

class tev_reg_values_t(object):
    r"""
    Proxy of C++ qvector< tev_reg_value_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> tev_reg_values_t
        __init__(self, x) -> tev_reg_values_t
        """
        _ida_dbg.tev_reg_values_t_swiginit(self, _ida_dbg.new_tev_reg_values_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_reg_values_t

    def push_back(self, *args) -> "tev_reg_value_t &":
        r"""
        push_back(self, x)
        push_back(self) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.tev_reg_values_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.tev_reg_values_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.tev_reg_values_t_empty(self, *args)

    def at(self, *args) -> "tev_reg_value_t const &":
        r"""
        at(self, _idx) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.tev_reg_values_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.tev_reg_values_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_dbg.tev_reg_values_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, x=tev_reg_value_t())
        """
        return _ida_dbg.tev_reg_values_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.tev_reg_values_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""
        reserve(self, cnt)
        """
        return _ida_dbg.tev_reg_values_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.tev_reg_values_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""
        swap(self, r)
        """
        return _ida_dbg.tev_reg_values_t_swap(self, *args)

    def extract(self, *args) -> "tev_reg_value_t *":
        r"""
        extract(self) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""
        inject(self, s, len)
        """
        return _ida_dbg.tev_reg_values_t_inject(self, *args)

    def begin(self, *args) -> "qvector< tev_reg_value_t >::const_iterator":
        r"""
        begin(self) -> tev_reg_value_t
        begin(self) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_begin(self, *args)

    def end(self, *args) -> "qvector< tev_reg_value_t >::const_iterator":
        r"""
        end(self) -> tev_reg_value_t
        end(self) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_end(self, *args)

    def insert(self, *args) -> "qvector< tev_reg_value_t >::iterator":
        r"""
        insert(self, it, x) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_insert(self, *args)

    def erase(self, *args) -> "qvector< tev_reg_value_t >::iterator":
        r"""
        erase(self, it) -> tev_reg_value_t
        erase(self, first, last) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.tev_reg_values_t___len__(self, *args)

    def __getitem__(self, *args) -> "tev_reg_value_t const &":
        r"""
        __getitem__(self, i) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, i, v)
        """
        return _ida_dbg.tev_reg_values_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register tev_reg_values_t in _ida_dbg:
_ida_dbg.tev_reg_values_t_swigregister(tev_reg_values_t)

class tevinforeg_vec_t(object):
    r"""
    Proxy of C++ qvector< tev_info_reg_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> tevinforeg_vec_t
        __init__(self, x) -> tevinforeg_vec_t
        """
        _ida_dbg.tevinforeg_vec_t_swiginit(self, _ida_dbg.new_tevinforeg_vec_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tevinforeg_vec_t

    def push_back(self, *args) -> "tev_info_reg_t &":
        r"""
        push_back(self, x)
        push_back(self) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.tevinforeg_vec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.tevinforeg_vec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.tevinforeg_vec_t_empty(self, *args)

    def at(self, *args) -> "tev_info_reg_t const &":
        r"""
        at(self, _idx) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.tevinforeg_vec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.tevinforeg_vec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_dbg.tevinforeg_vec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, x=tev_info_reg_t())
        """
        return _ida_dbg.tevinforeg_vec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.tevinforeg_vec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""
        reserve(self, cnt)
        """
        return _ida_dbg.tevinforeg_vec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.tevinforeg_vec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""
        swap(self, r)
        """
        return _ida_dbg.tevinforeg_vec_t_swap(self, *args)

    def extract(self, *args) -> "tev_info_reg_t *":
        r"""
        extract(self) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""
        inject(self, s, len)
        """
        return _ida_dbg.tevinforeg_vec_t_inject(self, *args)

    def begin(self, *args) -> "qvector< tev_info_reg_t >::const_iterator":
        r"""
        begin(self) -> tev_info_reg_t
        begin(self) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_begin(self, *args)

    def end(self, *args) -> "qvector< tev_info_reg_t >::const_iterator":
        r"""
        end(self) -> tev_info_reg_t
        end(self) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_end(self, *args)

    def insert(self, *args) -> "qvector< tev_info_reg_t >::iterator":
        r"""
        insert(self, it, x) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< tev_info_reg_t >::iterator":
        r"""
        erase(self, it) -> tev_info_reg_t
        erase(self, first, last) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.tevinforeg_vec_t___len__(self, *args)

    def __getitem__(self, *args) -> "tev_info_reg_t const &":
        r"""
        __getitem__(self, i) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, i, v)
        """
        return _ida_dbg.tevinforeg_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register tevinforeg_vec_t in _ida_dbg:
_ida_dbg.tevinforeg_vec_t_swigregister(tevinforeg_vec_t)

class memreg_infos_t(object):
    r"""
    Proxy of C++ qvector< memreg_info_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> memreg_infos_t
        __init__(self, x) -> memreg_infos_t
        """
        _ida_dbg.memreg_infos_t_swiginit(self, _ida_dbg.new_memreg_infos_t(*args))
    __swig_destroy__ = _ida_dbg.delete_memreg_infos_t

    def push_back(self, *args) -> "memreg_info_t &":
        r"""
        push_back(self, x)
        push_back(self) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.memreg_infos_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.memreg_infos_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.memreg_infos_t_empty(self, *args)

    def at(self, *args) -> "memreg_info_t const &":
        r"""
        at(self, _idx) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.memreg_infos_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.memreg_infos_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_dbg.memreg_infos_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, x=memreg_info_t())
        """
        return _ida_dbg.memreg_infos_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.memreg_infos_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""
        reserve(self, cnt)
        """
        return _ida_dbg.memreg_infos_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.memreg_infos_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""
        swap(self, r)
        """
        return _ida_dbg.memreg_infos_t_swap(self, *args)

    def extract(self, *args) -> "memreg_info_t *":
        r"""
        extract(self) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""
        inject(self, s, len)
        """
        return _ida_dbg.memreg_infos_t_inject(self, *args)

    def begin(self, *args) -> "qvector< memreg_info_t >::const_iterator":
        r"""
        begin(self) -> memreg_info_t
        begin(self) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_begin(self, *args)

    def end(self, *args) -> "qvector< memreg_info_t >::const_iterator":
        r"""
        end(self) -> memreg_info_t
        end(self) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_end(self, *args)

    def insert(self, *args) -> "qvector< memreg_info_t >::iterator":
        r"""
        insert(self, it, x) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_insert(self, *args)

    def erase(self, *args) -> "qvector< memreg_info_t >::iterator":
        r"""
        erase(self, it) -> memreg_info_t
        erase(self, first, last) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.memreg_infos_t___len__(self, *args)

    def __getitem__(self, *args) -> "memreg_info_t const &":
        r"""
        __getitem__(self, i) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, i, v)
        """
        return _ida_dbg.memreg_infos_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register memreg_infos_t in _ida_dbg:
_ida_dbg.memreg_infos_t_swigregister(memreg_infos_t)


def run_to(*args) -> "bool":
    r"""
    run_to(ea, pid=pid_t(-1), tid=0) -> bool


    Execute the process until the given address is reached. If no process
    is active, a new process is started. Technically, the debugger sets up
    a temporary breakpoint at the given address, and continues (or starts)
    the execution of the whole process. So, all threads continue their
    execution! \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_run_to' }
    
    @param ea: target address (C++: ea_t)
    @param pid: not used yet. please do not specify this parameter. (C++:
                pid_t)
    @param tid: not used yet. please do not specify this parameter. (C++:
                thid_t)
    """
    return _ida_dbg.run_to(*args)

def request_run_to(*args) -> "bool":
    r"""
    request_run_to(ea, pid=pid_t(-1), tid=0) -> bool


    Post a 'run_to()' request.
    
    
    @param ea (C++: ea_t)
    @param pid (C++: pid_t)
    @param tid (C++: thid_t)
    """
    return _ida_dbg.request_run_to(*args)

def set_debugger_event_cond(*args) -> "void":
    r"""
    set_debugger_event_cond(nonnul_cond)
    """
    return _ida_dbg.set_debugger_event_cond(*args)

def diff_trace_file(*args) -> "bool":
    r"""
    diff_trace_file(nonnul_filename) -> bool


    Show difference between the current trace and the one from 'filename'.
    """
    return _ida_dbg.diff_trace_file(*args)
dbg_null = _ida_dbg.dbg_null

dbg_process_start = _ida_dbg.dbg_process_start

dbg_process_exit = _ida_dbg.dbg_process_exit

dbg_process_attach = _ida_dbg.dbg_process_attach

dbg_process_detach = _ida_dbg.dbg_process_detach

dbg_thread_start = _ida_dbg.dbg_thread_start

dbg_thread_exit = _ida_dbg.dbg_thread_exit

dbg_library_load = _ida_dbg.dbg_library_load

dbg_library_unload = _ida_dbg.dbg_library_unload

dbg_information = _ida_dbg.dbg_information

dbg_exception = _ida_dbg.dbg_exception

dbg_suspend_process = _ida_dbg.dbg_suspend_process

dbg_bpt = _ida_dbg.dbg_bpt

dbg_trace = _ida_dbg.dbg_trace

dbg_request_error = _ida_dbg.dbg_request_error

dbg_step_into = _ida_dbg.dbg_step_into

dbg_step_over = _ida_dbg.dbg_step_over

dbg_run_to = _ida_dbg.dbg_run_to

dbg_step_until_ret = _ida_dbg.dbg_step_until_ret

dbg_bpt_changed = _ida_dbg.dbg_bpt_changed

dbg_started_loading_bpts = _ida_dbg.dbg_started_loading_bpts

dbg_finished_loading_bpts = _ida_dbg.dbg_finished_loading_bpts

dbg_last = _ida_dbg.dbg_last

BPTEV_ADDED = _ida_dbg.BPTEV_ADDED
"""
Breakpoint has been added.
"""

BPTEV_REMOVED = _ida_dbg.BPTEV_REMOVED
"""
Breakpoint has been removed.
"""

BPTEV_CHANGED = _ida_dbg.BPTEV_CHANGED
"""
Breakpoint has been modified.
"""


def run_requests(*args) -> "bool":
    r"""
    run_requests() -> bool


    Execute requests until all requests are processed or an asynchronous
    function is called. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}If called from a notification handler, the
    execution of requests will be postponed to the end of the execution of
    all notification handlers.
    
    @return: false if not all requests could be processed (indicates an
             asynchronous function was started)
    """
    return _ida_dbg.run_requests(*args)

def get_running_request(*args) -> "ui_notification_t":
    r"""
    get_running_request() -> ui_notification_t


    Get the current running request. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @return: ui_null if no running request
    """
    return _ida_dbg.get_running_request(*args)

def is_request_running(*args) -> "bool":
    r"""
    is_request_running() -> bool


    Is a request currently running?
    """
    return _ida_dbg.is_request_running(*args)

def get_running_notification(*args) -> "dbg_notification_t":
    r"""
    get_running_notification() -> dbg_notification_t


    Get the notification associated (if any) with the current running
    request. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @return: dbg_null if no running request
    """
    return _ida_dbg.get_running_notification(*args)

def clear_requests_queue(*args) -> "void":
    r"""
    clear_requests_queue()


    Clear the queue of waiting requests. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}If a request is currently
    running, this one isn't stopped.
    """
    return _ida_dbg.clear_requests_queue(*args)

def get_process_state(*args) -> "int":
    r"""
    get_process_state() -> int


    Return the state of the currently debugged process. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @return: one of  Debugged process states
    """
    return _ida_dbg.get_process_state(*args)
DSTATE_SUSP = _ida_dbg.DSTATE_SUSP
"""
process is suspended and will not continue
"""

DSTATE_NOTASK = _ida_dbg.DSTATE_NOTASK
"""
no process is currently debugged
"""

DSTATE_RUN = _ida_dbg.DSTATE_RUN
"""
process is running
"""

DBGINV_MEMORY = _ida_dbg.DBGINV_MEMORY
"""
invalidate cached memory contents
"""

DBGINV_MEMCFG = _ida_dbg.DBGINV_MEMCFG
"""
invalidate cached process segmentation
"""

DBGINV_REGS = _ida_dbg.DBGINV_REGS
"""
invalidate cached register values
"""

DBGINV_ALL = _ida_dbg.DBGINV_ALL
"""
invalidate everything
"""

DBGINV_REDRAW = _ida_dbg.DBGINV_REDRAW
"""
refresh the screen
"""

DBGINV_NONE = _ida_dbg.DBGINV_NONE
"""
invalidate nothing
"""


def set_process_state(*args) -> "int":
    r"""
    set_process_state(newstate, p_thid, dbginv) -> int


    Set new state for the debugged process. Notifies the IDA kernel about
    the change of the debugged process state. For example, a debugger
    module could call this function when it knows that the process is
    suspended for a short period of time. Some IDA API calls can be made
    only when the process is suspended. The process state is usually
    restored before returning control to the caller. You must know that it
    is ok to change the process state, doing it at arbitrary moments may
    crash the application or IDA. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param newstate: new process state (one of  Debugged process states )
                     if  DSTATE_NOTASK  is passed then the state is not
                     changed (C++: int)
    @param p_thid: ptr to new thread id. may be NULL or pointer to
                   NO_THREAD . the pointed variable will contain the old
                   thread id upon return (C++: thid_t  *)
    @param dbginv: Debugged process invalidation options (C++: int)
    @return: old debugger state (one of  Debugged process states )
    """
    return _ida_dbg.set_process_state(*args)

def invalidate_dbg_state(*args) -> "int":
    r"""
    invalidate_dbg_state(dbginv) -> int


    Invalidate cached debugger information. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param dbginv: Debugged process invalidation options (C++: int)
    @return: current debugger state (one of  Debugged process states )
    """
    return _ida_dbg.invalidate_dbg_state(*args)

def start_process(*args) -> "int":
    r"""
    start_process(path=None, args=None, sdir=None) -> int


    Start a process in the debugger. \sq{Type, Asynchronous function -
    available as Request, Notification, 'dbg_process_start' }You can also
    use the 'run_to()' function to easily start the execution of a process
    until a given address is reached.For all parameters, a NULL value
    indicates the debugger will take the value from the defined Process
    Options.
    
    @param path: path to the executable to start (C++: const char *)
    @param args: arguments to pass to process (C++: const char *)
    @param sdir: starting directory for the process (C++: const char *)
    """
    return _ida_dbg.start_process(*args)

def request_start_process(*args) -> "int":
    r"""
    request_start_process(path=None, args=None, sdir=None) -> int


    Post a 'start_process()' request.
    
    
    @param path (C++: const char *)
    @param args (C++: const char *)
    @param sdir (C++: const char *)
    """
    return _ida_dbg.request_start_process(*args)

def suspend_process(*args) -> "bool":
    r"""
    suspend_process() -> bool


    Suspend the process in the debugger. \sq{ Type,Synchronous function
    (if in a notification handler)Asynchronous function (everywhere
    else)available as Request, Notification,none (if in a notification
    handler) 'dbg_suspend_process' (everywhere else) }The
    'suspend_process()' function can be called from a notification handler
    to force the stopping of the process. In this case, no notification
    will be generated. When you suspend a process, the running command is
    always aborted.
    """
    return _ida_dbg.suspend_process(*args)

def request_suspend_process(*args) -> "bool":
    r"""
    request_suspend_process() -> bool


    Post a 'suspend_process()' request.
    """
    return _ida_dbg.request_suspend_process(*args)

def continue_process(*args) -> "bool":
    r"""
    continue_process() -> bool


    Continue the execution of the process in the debugger. \sq{Type,
    Synchronous function - available as Request, Notification, none
    (synchronous function)}The 'continue_process()' function can be called
    from a notification handler to force the continuation of the process.
    In this case the request queue will not be examined, IDA will simply
    resume execution. Usually it makes sense to call
    'request_continue_process()' followed by 'run_requests()' , so that
    IDA will first start a queued request (if any) and then resume the
    application.
    """
    return _ida_dbg.continue_process(*args)

def request_continue_process(*args) -> "bool":
    r"""
    request_continue_process() -> bool


    Post a 'continue_process()' request.This requires an explicit call to
    'run_requests()'
    """
    return _ida_dbg.request_continue_process(*args)

def exit_process(*args) -> "bool":
    r"""
    exit_process() -> bool


    Terminate the debugging of the current process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_exit' }
    """
    return _ida_dbg.exit_process(*args)

def request_exit_process(*args) -> "bool":
    r"""
    request_exit_process() -> bool


    Post an 'exit_process()' request.
    """
    return _ida_dbg.request_exit_process(*args)

def get_processes(*args) -> "ssize_t":
    r"""
    get_processes(proclist) -> ssize_t


    Take a snapshot of running processes and return their description.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @param proclist (C++: procinfo_vec_t  *)
    @return: number of processes or -1 on error
    """
    return _ida_dbg.get_processes(*args)

def attach_process(*args) -> "int":
    r"""
    attach_process(pid=pid_t(-1), event_id=-1) -> int


    Attach the debugger to a running process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_attach'
    }This function shouldn't be called as a request if 'NO_PROCESS' is
    used.
    
    @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
                box will interactively ask the user for the process to
                attach to. (C++: pid_t)
    @param event_id (C++: int)
    """
    return _ida_dbg.attach_process(*args)

def request_attach_process(*args) -> "int":
    r"""
    request_attach_process(pid, event_id) -> int


    Post an 'attach_process()' request.
    
    
    @param pid (C++: pid_t)
    @param event_id (C++: int)
    """
    return _ida_dbg.request_attach_process(*args)

def detach_process(*args) -> "bool":
    r"""
    detach_process() -> bool


    Detach the debugger from the debugged process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_detach' }
    """
    return _ida_dbg.detach_process(*args)

def request_detach_process(*args) -> "bool":
    r"""
    request_detach_process() -> bool


    Post a 'detach_process()' request.
    """
    return _ida_dbg.request_detach_process(*args)

def is_debugger_busy(*args) -> "bool":
    r"""
    is_debugger_busy() -> bool


    Is the debugger busy?. Some debuggers do not accept any commands while
    the debugged application is running. For such a debugger, it is unsafe
    to do anything with the database (even simple queries like get_byte
    may lead to undesired consequences). Returns: true if the debugged
    application is running under such a debugger
    """
    return _ida_dbg.is_debugger_busy(*args)

def get_thread_qty(*args) -> "int":
    r"""
    get_thread_qty() -> int


    Get number of threads. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    """
    return _ida_dbg.get_thread_qty(*args)

def getn_thread(*args) -> "thid_t":
    r"""
    getn_thread(n) -> thid_t


    Get the ID of a thread. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
              int)
    @return: NO_THREAD  if the thread doesn't exist.
    """
    return _ida_dbg.getn_thread(*args)

def get_current_thread(*args) -> "thid_t":
    r"""
    get_current_thread() -> thid_t


    Get current thread ID. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    """
    return _ida_dbg.get_current_thread(*args)

def getn_thread_name(*args) -> "char const *":
    r"""
    getn_thread_name(n) -> char const *


    Get the NAME of a thread \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
              for the current thread (C++: int)
    @return: thread name or NULL if the thread doesn't exist.
    """
    return _ida_dbg.getn_thread_name(*args)

def select_thread(*args) -> "bool":
    r"""
    select_thread(tid) -> bool


    Select the given thread as the current debugged thread. All thread
    related execution functions will work on this thread. The process must
    be suspended to select a new thread. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param tid: ID of the thread to select (C++: thid_t)
    @return: false if the thread doesn't exist.
    """
    return _ida_dbg.select_thread(*args)

def request_select_thread(*args) -> "bool":
    r"""
    request_select_thread(tid) -> bool


    Post a 'select_thread()' request.
    
    
    @param tid (C++: thid_t)
    """
    return _ida_dbg.request_select_thread(*args)

def suspend_thread(*args) -> "int":
    r"""
    suspend_thread(tid) -> int


    Suspend thread. Suspending a thread may deadlock the whole application
    if the suspended was owning some synchronization objects. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    @param tid: thread id (C++: thid_t)
    """
    return _ida_dbg.suspend_thread(*args)

def request_suspend_thread(*args) -> "int":
    r"""
    request_suspend_thread(tid) -> int


    Post a 'suspend_thread()' request.
    
    
    @param tid (C++: thid_t)
    """
    return _ida_dbg.request_suspend_thread(*args)

def resume_thread(*args) -> "int":
    r"""
    resume_thread(tid) -> int


    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: thread id (C++: thid_t)
    """
    return _ida_dbg.resume_thread(*args)

def request_resume_thread(*args) -> "int":
    r"""
    request_resume_thread(tid) -> int


    Post a 'resume_thread()' request.
    
    
    @param tid (C++: thid_t)
    """
    return _ida_dbg.request_resume_thread(*args)

def get_first_module(*args) -> "bool":
    r"""
    get_first_module(modinfo) -> bool
    """
    return _ida_dbg.get_first_module(*args)

def get_next_module(*args) -> "bool":
    r"""
    get_next_module(modinfo) -> bool
    """
    return _ida_dbg.get_next_module(*args)

def step_into(*args) -> "bool":
    r"""
    step_into() -> bool


    Execute one instruction in the current thread. Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_into' }
    """
    return _ida_dbg.step_into(*args)

def request_step_into(*args) -> "bool":
    r"""
    request_step_into() -> bool


    Post a 'step_into()' request.
    """
    return _ida_dbg.request_step_into(*args)

def step_over(*args) -> "bool":
    r"""
    step_over() -> bool


    Execute one instruction in the current thread, but without entering
    into functions. Others threads keep suspended. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_step_over' }
    """
    return _ida_dbg.step_over(*args)

def request_step_over(*args) -> "bool":
    r"""
    request_step_over() -> bool


    Post a 'step_over()' request.
    """
    return _ida_dbg.request_step_over(*args)

def step_until_ret(*args) -> "bool":
    r"""
    step_until_ret() -> bool


    Execute instructions in the current thread until a function return
    instruction is executed (aka "step out"). Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_until_ret' }
    """
    return _ida_dbg.step_until_ret(*args)

def request_step_until_ret(*args) -> "bool":
    r"""
    request_step_until_ret() -> bool


    Post a 'step_until_ret()' request.
    """
    return _ida_dbg.request_step_until_ret(*args)

def set_resume_mode(*args) -> "bool":
    r"""
    set_resume_mode(tid, mode) -> bool


    How to resume the application. Set resume mode but do not resume
    process.
    
    @param tid (C++: thid_t)
    @param mode (C++: resume_mode_t)
    """
    return _ida_dbg.set_resume_mode(*args)

def request_set_resume_mode(*args) -> "bool":
    r"""
    request_set_resume_mode(tid, mode) -> bool


    Post a 'set_resume_mode()' request.
    
    
    @param tid (C++: thid_t)
    @param mode (C++: resume_mode_t)
    """
    return _ida_dbg.request_set_resume_mode(*args)

def get_dbg_reg_info(*args) -> "bool":
    r"""
    get_dbg_reg_info(regname, ri) -> bool


    Get register information \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param regname (C++: const char *)
    @param ri (C++: register_info_t  *)
    """
    return _ida_dbg.get_dbg_reg_info(*args)

def get_sp_val(*args) -> "uint64 *":
    r"""
    get_sp_val() -> bool


    Get value of the SP register for the current thread. Requires a
    suspended debugger.
    """
    return _ida_dbg.get_sp_val(*args)

def get_ip_val(*args) -> "uint64 *":
    r"""
    get_ip_val() -> bool


    Get value of the IP (program counter) register for the current thread.
    Requires a suspended debugger.
    """
    return _ida_dbg.get_ip_val(*args)

def is_reg_integer(*args) -> "bool":
    r"""
    is_reg_integer(regname) -> bool


    Does a register contain an integer value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)
    """
    return _ida_dbg.is_reg_integer(*args)

def is_reg_float(*args) -> "bool":
    r"""
    is_reg_float(regname) -> bool


    Does a register contain a floating point value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)
    """
    return _ida_dbg.is_reg_float(*args)

def is_reg_custom(*args) -> "bool":
    r"""
    is_reg_custom(regname) -> bool


    Does a register contain a value of a custom data type? \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)
    """
    return _ida_dbg.is_reg_custom(*args)

def set_bptloc_string(*args) -> "int":
    r"""
    set_bptloc_string(s) -> int


    Helper function for 'bpt_location_t' .
    
    
    @param s (C++: const char *)
    """
    return _ida_dbg.set_bptloc_string(*args)

def get_bptloc_string(*args) -> "char const *":
    r"""
    get_bptloc_string(i) -> char const *


    Helper function for 'bpt_location_t' .
    
    
    @param i (C++: int)
    """
    return _ida_dbg.get_bptloc_string(*args)
BPLT_ABS = _ida_dbg.BPLT_ABS

BPLT_REL = _ida_dbg.BPLT_REL

BPLT_SYM = _ida_dbg.BPLT_SYM

BPLT_SRC = _ida_dbg.BPLT_SRC

class bpt_location_t(object):
    r"""
    Proxy of C++ bpt_location_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    info = property(_ida_dbg.bpt_location_t_info_get, _ida_dbg.bpt_location_t_info_set)
    index = property(_ida_dbg.bpt_location_t_index_get, _ida_dbg.bpt_location_t_index_set)
    loctype = property(_ida_dbg.bpt_location_t_loctype_get, _ida_dbg.bpt_location_t_loctype_set)

    def type(self, *args) -> "bpt_loctype_t":
        r"""
        type(self) -> bpt_loctype_t
        """
        return _ida_dbg.bpt_location_t_type(self, *args)

    def is_empty_path(self, *args) -> "bool":
        r"""
        is_empty_path(self) -> bool
        """
        return _ida_dbg.bpt_location_t_is_empty_path(self, *args)

    def path(self, *args) -> "char const *":
        r"""
        path(self) -> char const *
        """
        return _ida_dbg.bpt_location_t_path(self, *args)

    def symbol(self, *args) -> "char const *":
        r"""
        symbol(self) -> char const *
        """
        return _ida_dbg.bpt_location_t_symbol(self, *args)

    def lineno(self, *args) -> "int":
        r"""
        lineno(self) -> int
        """
        return _ida_dbg.bpt_location_t_lineno(self, *args)

    def offset(self, *args) -> "uval_t":
        r"""
        offset(self) -> uval_t
        """
        return _ida_dbg.bpt_location_t_offset(self, *args)

    def ea(self, *args) -> "ea_t":
        r"""
        ea(self) -> ea_t
        """
        return _ida_dbg.bpt_location_t_ea(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> bpt_location_t
        """
        _ida_dbg.bpt_location_t_swiginit(self, _ida_dbg.new_bpt_location_t(*args))

    def set_abs_bpt(self, *args) -> "void":
        r"""
        set_abs_bpt(self, a)
        """
        return _ida_dbg.bpt_location_t_set_abs_bpt(self, *args)

    def set_src_bpt(self, *args) -> "void":
        r"""
        set_src_bpt(self, fn, _lineno)
        """
        return _ida_dbg.bpt_location_t_set_src_bpt(self, *args)

    def set_sym_bpt(self, *args) -> "void":
        r"""
        set_sym_bpt(self, _symbol, _offset=0)
        """
        return _ida_dbg.bpt_location_t_set_sym_bpt(self, *args)

    def set_rel_bpt(self, *args) -> "void":
        r"""
        set_rel_bpt(self, mod, _offset)
        """
        return _ida_dbg.bpt_location_t_set_rel_bpt(self, *args)

    def compare(self, *args) -> "int":
        r"""
        compare(self, r) -> int
        """
        return _ida_dbg.bpt_location_t_compare(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_dbg.bpt_location_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_dbg.bpt_location_t___ne__(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""
        __lt__(self, r) -> bool
        """
        return _ida_dbg.bpt_location_t___lt__(self, *args)

    def __gt__(self, *args) -> "bool":
        r"""
        __gt__(self, r) -> bool
        """
        return _ida_dbg.bpt_location_t___gt__(self, *args)

    def __le__(self, *args) -> "bool":
        r"""
        __le__(self, r) -> bool
        """
        return _ida_dbg.bpt_location_t___le__(self, *args)

    def __ge__(self, *args) -> "bool":
        r"""
        __ge__(self, r) -> bool
        """
        return _ida_dbg.bpt_location_t___ge__(self, *args)
    __swig_destroy__ = _ida_dbg.delete_bpt_location_t

# Register bpt_location_t in _ida_dbg:
_ida_dbg.bpt_location_t_swigregister(bpt_location_t)

class bpt_t(object):
    r"""
    Proxy of C++ bpt_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cb = property(_ida_dbg.bpt_t_cb_get, _ida_dbg.bpt_t_cb_set)
    loc = property(_ida_dbg.bpt_t_loc_get, _ida_dbg.bpt_t_loc_set)
    pid = property(_ida_dbg.bpt_t_pid_get, _ida_dbg.bpt_t_pid_set)
    tid = property(_ida_dbg.bpt_t_tid_get, _ida_dbg.bpt_t_tid_set)
    ea = property(_ida_dbg.bpt_t_ea_get, _ida_dbg.bpt_t_ea_set)
    type = property(_ida_dbg.bpt_t_type_get, _ida_dbg.bpt_t_type_set)
    pass_count = property(_ida_dbg.bpt_t_pass_count_get, _ida_dbg.bpt_t_pass_count_set)
    flags = property(_ida_dbg.bpt_t_flags_get, _ida_dbg.bpt_t_flags_set)
    props = property(_ida_dbg.bpt_t_props_get, _ida_dbg.bpt_t_props_set)
    size = property(_ida_dbg.bpt_t_size_get, _ida_dbg.bpt_t_size_set)
    cndidx = property(_ida_dbg.bpt_t_cndidx_get, _ida_dbg.bpt_t_cndidx_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> bpt_t
        """
        _ida_dbg.bpt_t_swiginit(self, _ida_dbg.new_bpt_t(*args))

    def is_hwbpt(self, *args) -> "bool":
        r"""
        is_hwbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_hwbpt(self, *args)

    def enabled(self, *args) -> "bool":
        r"""
        enabled(self) -> bool
        """
        return _ida_dbg.bpt_t_enabled(self, *args)

    def is_low_level(self, *args) -> "bool":
        r"""
        is_low_level(self) -> bool
        """
        return _ida_dbg.bpt_t_is_low_level(self, *args)

    def badbpt(self, *args) -> "bool":
        r"""
        badbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_badbpt(self, *args)

    def listbpt(self, *args) -> "bool":
        r"""
        listbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_listbpt(self, *args)

    def is_compiled(self, *args) -> "bool":
        r"""
        is_compiled(self) -> bool
        """
        return _ida_dbg.bpt_t_is_compiled(self, *args)

    def is_active(self, *args) -> "bool":
        r"""
        is_active(self) -> bool
        """
        return _ida_dbg.bpt_t_is_active(self, *args)

    def is_partially_active(self, *args) -> "bool":
        r"""
        is_partially_active(self) -> bool
        """
        return _ida_dbg.bpt_t_is_partially_active(self, *args)

    def is_inactive(self, *args) -> "bool":
        r"""
        is_inactive(self) -> bool
        """
        return _ida_dbg.bpt_t_is_inactive(self, *args)

    def is_page_bpt(self, *args) -> "bool":
        r"""
        is_page_bpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_page_bpt(self, *args)

    def get_size(self, *args) -> "int":
        r"""
        get_size(self) -> int
        """
        return _ida_dbg.bpt_t_get_size(self, *args)

    def set_abs_bpt(self, *args) -> "void":
        r"""
        set_abs_bpt(self, a)
        """
        return _ida_dbg.bpt_t_set_abs_bpt(self, *args)

    def set_src_bpt(self, *args) -> "void":
        r"""
        set_src_bpt(self, fn, lineno)
        """
        return _ida_dbg.bpt_t_set_src_bpt(self, *args)

    def set_sym_bpt(self, *args) -> "void":
        r"""
        set_sym_bpt(self, sym, o)
        """
        return _ida_dbg.bpt_t_set_sym_bpt(self, *args)

    def set_rel_bpt(self, *args) -> "void":
        r"""
        set_rel_bpt(self, mod, o)
        """
        return _ida_dbg.bpt_t_set_rel_bpt(self, *args)

    def is_absbpt(self, *args) -> "bool":
        r"""
        is_absbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_absbpt(self, *args)

    def is_relbpt(self, *args) -> "bool":
        r"""
        is_relbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_relbpt(self, *args)

    def is_symbpt(self, *args) -> "bool":
        r"""
        is_symbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_symbpt(self, *args)

    def is_srcbpt(self, *args) -> "bool":
        r"""
        is_srcbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_srcbpt(self, *args)

    def is_tracemodebpt(self, *args) -> "bool":
        r"""
        is_tracemodebpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_tracemodebpt(self, *args)

    def is_traceonbpt(self, *args) -> "bool":
        r"""
        is_traceonbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_traceonbpt(self, *args)

    def is_traceoffbpt(self, *args) -> "bool":
        r"""
        is_traceoffbpt(self) -> bool
        """
        return _ida_dbg.bpt_t_is_traceoffbpt(self, *args)

    def set_trace_action(self, *args) -> "bool":
        r"""
        set_trace_action(self, enable, trace_types) -> bool
        """
        return _ida_dbg.bpt_t_set_trace_action(self, *args)

    def get_cnd_elang_idx(self, *args) -> "size_t":
        r"""
        get_cnd_elang_idx(self) -> size_t
        """
        return _ida_dbg.bpt_t_get_cnd_elang_idx(self, *args)
    condition = property(_ida_dbg.bpt_t_condition_get, _ida_dbg.bpt_t_condition_set)
    elang = property(_ida_dbg.bpt_t_elang_get, _ida_dbg.bpt_t_elang_set)
    __swig_destroy__ = _ida_dbg.delete_bpt_t

# Register bpt_t in _ida_dbg:
_ida_dbg.bpt_t_swigregister(bpt_t)
BPT_BRK = _ida_dbg.BPT_BRK
"""
suspend execution upon hit
"""

BPT_TRACE = _ida_dbg.BPT_TRACE
"""
add trace information upon hit
"""

BPT_UPDMEM = _ida_dbg.BPT_UPDMEM
"""
refresh the memory layout and contents before evaluating bpt condition
"""

BPT_ENABLED = _ida_dbg.BPT_ENABLED
"""
enabled?
"""

BPT_LOWCND = _ida_dbg.BPT_LOWCND
"""
condition is calculated at low level (on the server side)
"""

BPT_TRACEON = _ida_dbg.BPT_TRACEON
"""
enable tracing when the breakpoint is reached
"""

BPT_TRACE_INSN = _ida_dbg.BPT_TRACE_INSN
"""
instruction tracing
"""

BPT_TRACE_FUNC = _ida_dbg.BPT_TRACE_FUNC
"""
function tracing
"""

BPT_TRACE_BBLK = _ida_dbg.BPT_TRACE_BBLK
"""
basic block tracing
"""

BPT_TRACE_TYPES = _ida_dbg.BPT_TRACE_TYPES
"""
trace insns, functions, and basic blocks. if any of 'BPT_TRACE_TYPES'
bits are set but 'BPT_TRACEON' is clear, then turn off tracing for the
specified trace types
"""

BPT_ELANG_MASK = _ida_dbg.BPT_ELANG_MASK

BPT_ELANG_SHIFT = _ida_dbg.BPT_ELANG_SHIFT
"""
index of the extlang (scripting language) of the condition
"""

BKPT_BADBPT = _ida_dbg.BKPT_BADBPT
"""
failed to write the bpt to the process memory (at least one location)
"""

BKPT_LISTBPT = _ida_dbg.BKPT_LISTBPT
"""
include in bpt list (user-defined bpt)
"""

BKPT_TRACE = _ida_dbg.BKPT_TRACE
"""
trace bpt; should not be deleted when the process gets suspended
"""

BKPT_ACTIVE = _ida_dbg.BKPT_ACTIVE
"""
active?
"""

BKPT_PARTIAL = _ida_dbg.BKPT_PARTIAL
"""
partially active? (some locations were not written yet)
"""

BKPT_CNDREADY = _ida_dbg.BKPT_CNDREADY
"""
condition has been compiled
"""

BKPT_FAKEPEND = _ida_dbg.BKPT_FAKEPEND
"""
bpt of the same type is active at the same address(es)

fake pending bpt: it is inactive but another
"""

BKPT_PAGE = _ida_dbg.BKPT_PAGE
"""
only after writing the bpt to the process.

written to the process as a page bpt. is available
"""


MOVBPT_OK = _ida_dbg.MOVBPT_OK

MOVBPT_NOT_FOUND = _ida_dbg.MOVBPT_NOT_FOUND

MOVBPT_DEST_BUSY = _ida_dbg.MOVBPT_DEST_BUSY

MOVBPT_BAD_TYPE = _ida_dbg.MOVBPT_BAD_TYPE


def get_bpt_qty(*args) -> "int":
    r"""
    get_bpt_qty() -> int


    Get number of breakpoints. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    """
    return _ida_dbg.get_bpt_qty(*args)

def getn_bpt(*args) -> "bool":
    r"""
    getn_bpt(n, bpt) -> bool


    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: number of breakpoint, is in range 0.. get_bpt_qty() -1 (C++:
              int)
    @param bpt: filled with the characteristics. (C++: bpt_t  *)
    @return: false if no breakpoint exists
    """
    return _ida_dbg.getn_bpt(*args)

def get_bpt(*args) -> "bool":
    r"""
    get_bpt(ea, bpt) -> bool


    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param ea: any address in the breakpoint range (C++: ea_t)
    @param bpt: if not NULL, is filled with the characteristics. (C++:
                bpt_t  *)
    @return: false if no breakpoint exists
    """
    return _ida_dbg.get_bpt(*args)

def exist_bpt(*args) -> "bool":
    r"""
    exist_bpt(ea) -> bool


    Does a breakpoint exist at the given location?
    
    
    @param ea (C++: ea_t)
    """
    return _ida_dbg.exist_bpt(*args)

def add_bpt(*args) -> "bool":
    r"""
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    add_bpt(bpt) -> bool


    Add a new breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous
    function)}Only one breakpoint can exist at a given address.
    
    @param ea: any address in the process memory space. Depending on the
               architecture, hardware breakpoints always be setup at
               random address. For example, on x86, hardware breakpoints
               should be aligned depending on their size. Moreover, on the
               x86 architecture, it is impossible to setup more than 4
               hardware breakpoints. (C++: ea_t)
    @param size: size of the breakpoint (irrelevant for software
                 breakpoints): As for the address, hardware breakpoints
                 can't always be setup with random size. (C++: asize_t)
    @param type: type of the breakpoint ( BPT_SOFT  for software
                 breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |
                 BPT_EXEC ): try to add instruction breakpoint of the
                 appropriate type as follows: software bpt if supported,
                 hwbpt otherwise (C++: bpttype_t)
    """
    return _ida_dbg.add_bpt(*args)

def request_add_bpt(*args) -> "bool":
    r"""
    request_add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    request_add_bpt(bpt) -> bool


    Post an 'add_bpt(ea_t, asize_t, bpttype_t)' request.
    
    
    @param ea (C++: ea_t)
    @param size (C++: asize_t)
    @param type (C++: bpttype_t)
    """
    return _ida_dbg.request_add_bpt(*args)

def del_bpt(*args) -> "bool":
    r"""
    del_bpt(ea) -> bool
    del_bpt(bptloc) -> bool


    Delete an existing breakpoint in the debugged process. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    @param ea: any address in the breakpoint range (C++: ea_t)
    """
    return _ida_dbg.del_bpt(*args)

def request_del_bpt(*args) -> "bool":
    r"""
    request_del_bpt(ea) -> bool
    request_del_bpt(bptloc) -> bool


    Post a 'del_bpt(ea_t)' request.
    
    
    @param ea (C++: ea_t)
    """
    return _ida_dbg.request_del_bpt(*args)

def update_bpt(*args) -> "bool":
    r"""
    update_bpt(bpt) -> bool


    Update modifiable characteristics of an existing breakpoint. To update
    the breakpoint location, use 'change_bptlocs()' \sq{Type, Synchronous
    function, Notification, none (synchronous function)}Only the following
    fields can be modified: 'bpt_t::cndbody'  'bpt_t::pass_count'
    'bpt_t::flags'  'bpt_t::size'  'bpt_t::type' Changing some properties
    will require removing and then re-adding the breakpoint to the process
    memory (or the debugger backend), which can lead to race conditions
    (i.e., breakpoint(s) can be missed) in case the process is not
    suspended. Here are a list of scenarios that will require the
    breakpoint to be removed & then re-added: 'bpt_t::size' is modified
    'bpt_t::type' is modified 'bpt_t::flags' 's BPT_ENABLED is modified
    'bpt_t::flags' 's BPT_LOWCND is changed 'bpt_t::flags' 's BPT_LOWCND
    remains set, but cndbody changed
    
    @param bpt (C++: const  bpt_t  *)
    """
    return _ida_dbg.update_bpt(*args)

def find_bpt(*args) -> "bool":
    r"""
    find_bpt(bptloc, bpt) -> bool


    Find a breakpoint by location. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param bptloc: Breakpoint location (C++: const  bpt_location_t  &)
    @param bpt: bpt is filled if the breakpoint was found (C++: bpt_t  *)
    """
    return _ida_dbg.find_bpt(*args)

def enable_bpt(*args) -> "bool":
    r"""
    enable_bpt(ea, enable=True) -> bool
    enable_bpt(bptloc, enable=True) -> bool
    """
    return _ida_dbg.enable_bpt(*args)

def disable_bpt(*args) -> "bool":
    r"""
    disable_bpt(ea) -> bool
    disable_bpt(bptloc) -> bool
    """
    return _ida_dbg.disable_bpt(*args)

def request_enable_bpt(*args) -> "bool":
    r"""
    request_enable_bpt(ea, enable=True) -> bool
    request_enable_bpt(bptloc, enable=True) -> bool
    """
    return _ida_dbg.request_enable_bpt(*args)

def request_disable_bpt(*args) -> "bool":
    r"""
    request_disable_bpt(ea) -> bool
    request_disable_bpt(bptloc) -> bool
    """
    return _ida_dbg.request_disable_bpt(*args)

def check_bpt(*args) -> "int":
    r"""
    check_bpt(ea) -> int


    Check the breakpoint at the specified address.
    
    @param ea (C++: ea_t)
    @return: one of  Breakpoint status codes
    """
    return _ida_dbg.check_bpt(*args)
BPTCK_NONE = _ida_dbg.BPTCK_NONE
"""
breakpoint does not exist
"""

BPTCK_NO = _ida_dbg.BPTCK_NO
"""
breakpoint is disabled
"""

BPTCK_YES = _ida_dbg.BPTCK_YES
"""
breakpoint is enabled
"""

BPTCK_ACT = _ida_dbg.BPTCK_ACT
"""
breakpoint is active (written to the process)
"""


def set_trace_size(*args) -> "bool":
    r"""
    set_trace_size(size) -> bool


    Specify the new size of the circular buffer. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}If you specify 0,
    all available memory can be quickly used !!!
    
    @param size: if 0, buffer isn't circular and events are never removed.
                 If the new size is smaller than the existing number of
                 trace events, a corresponding number of trace events are
                 removed. (C++: int)
    """
    return _ida_dbg.set_trace_size(*args)

def clear_trace(*args) -> "void":
    r"""
    clear_trace()


    Clear all events in the trace buffer. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    """
    return _ida_dbg.clear_trace(*args)

def request_clear_trace(*args) -> "void":
    r"""
    request_clear_trace()


    Post a 'clear_trace()' request.
    """
    return _ida_dbg.request_clear_trace(*args)

def is_step_trace_enabled(*args) -> "bool":
    r"""
    is_step_trace_enabled() -> bool


    Get current state of step tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    """
    return _ida_dbg.is_step_trace_enabled(*args)

def enable_step_trace(*args) -> "bool":
    r"""
    enable_step_trace(enable=True) -> bool
    """
    return _ida_dbg.enable_step_trace(*args)

def disable_step_trace(*args) -> "bool":
    r"""
    disable_step_trace() -> bool
    """
    return _ida_dbg.disable_step_trace(*args)

def request_enable_step_trace(*args) -> "bool":
    r"""
    request_enable_step_trace(enable=True) -> bool
    """
    return _ida_dbg.request_enable_step_trace(*args)

def request_disable_step_trace(*args) -> "bool":
    r"""
    request_disable_step_trace() -> bool
    """
    return _ida_dbg.request_disable_step_trace(*args)
ST_OVER_DEBUG_SEG = _ida_dbg.ST_OVER_DEBUG_SEG
"""
step tracing will be disabled when IP is in a debugger segment
"""

ST_OVER_LIB_FUNC = _ida_dbg.ST_OVER_LIB_FUNC
"""
step tracing will be disabled when IP is in a library function
"""

ST_ALREADY_LOGGED = _ida_dbg.ST_ALREADY_LOGGED
"""
step tracing will be disabled when IP is already logged
"""

ST_SKIP_LOOPS = _ida_dbg.ST_SKIP_LOOPS
"""
step tracing will try to skip loops already recorded
"""

ST_DIFFERENTIAL = _ida_dbg.ST_DIFFERENTIAL
"""
tracing: log only new instructions
"""

ST_OPTIONS_MASK = _ida_dbg.ST_OPTIONS_MASK
"""
mask of available options, to ensure compatibility with newer IDA
versions
"""

ST_OPTIONS_DEFAULT = _ida_dbg.ST_OPTIONS_DEFAULT

FT_LOG_RET = _ida_dbg.FT_LOG_RET
"""
function tracing will log returning instructions
"""

BT_LOG_INSTS = _ida_dbg.BT_LOG_INSTS
"""
log all instructions in the current basic block
"""

IT_LOG_SAME_IP = _ida_dbg.IT_LOG_SAME_IP
"""
instruction tracing will log instructions whose IP doesn't change
"""


def get_step_trace_options(*args) -> "int":
    r"""
    get_step_trace_options() -> int


    Get current step tracing options. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @return: Step trace options
    """
    return _ida_dbg.get_step_trace_options(*args)

def set_step_trace_options(*args) -> "void":
    r"""
    set_step_trace_options(options)


    Modify step tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param options (C++: int)
    """
    return _ida_dbg.set_step_trace_options(*args)

def request_set_step_trace_options(*args) -> "void":
    r"""
    request_set_step_trace_options(options)


    Post a 'set_step_trace_options()' request.
    
    
    @param options (C++: int)
    """
    return _ida_dbg.request_set_step_trace_options(*args)

def is_insn_trace_enabled(*args) -> "bool":
    r"""
    is_insn_trace_enabled() -> bool


    Get current state of instructions tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    """
    return _ida_dbg.is_insn_trace_enabled(*args)

def enable_insn_trace(*args) -> "bool":
    r"""
    enable_insn_trace(enable=True) -> bool
    """
    return _ida_dbg.enable_insn_trace(*args)

def disable_insn_trace(*args) -> "bool":
    r"""
    disable_insn_trace() -> bool
    """
    return _ida_dbg.disable_insn_trace(*args)

def request_enable_insn_trace(*args) -> "bool":
    r"""
    request_enable_insn_trace(enable=True) -> bool
    """
    return _ida_dbg.request_enable_insn_trace(*args)

def request_disable_insn_trace(*args) -> "bool":
    r"""
    request_disable_insn_trace() -> bool
    """
    return _ida_dbg.request_disable_insn_trace(*args)

def get_insn_trace_options(*args) -> "int":
    r"""
    get_insn_trace_options() -> int


    Get current instruction tracing options. Also see 'IT_LOG_SAME_IP'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    """
    return _ida_dbg.get_insn_trace_options(*args)

def set_insn_trace_options(*args) -> "void":
    r"""
    set_insn_trace_options(options)


    Modify instruction tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param options (C++: int)
    """
    return _ida_dbg.set_insn_trace_options(*args)

def request_set_insn_trace_options(*args) -> "void":
    r"""
    request_set_insn_trace_options(options)


    Post a 'set_insn_trace_options()' request.
    
    
    @param options (C++: int)
    """
    return _ida_dbg.request_set_insn_trace_options(*args)

def is_func_trace_enabled(*args) -> "bool":
    r"""
    is_func_trace_enabled() -> bool


    Get current state of functions tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    """
    return _ida_dbg.is_func_trace_enabled(*args)

def enable_func_trace(*args) -> "bool":
    r"""
    enable_func_trace(enable=True) -> bool
    """
    return _ida_dbg.enable_func_trace(*args)

def disable_func_trace(*args) -> "bool":
    r"""
    disable_func_trace() -> bool
    """
    return _ida_dbg.disable_func_trace(*args)

def request_enable_func_trace(*args) -> "bool":
    r"""
    request_enable_func_trace(enable=True) -> bool
    """
    return _ida_dbg.request_enable_func_trace(*args)

def request_disable_func_trace(*args) -> "bool":
    r"""
    request_disable_func_trace() -> bool
    """
    return _ida_dbg.request_disable_func_trace(*args)

def get_func_trace_options(*args) -> "int":
    r"""
    get_func_trace_options() -> int


    Get current function tracing options. Also see 'FT_LOG_RET' \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    """
    return _ida_dbg.get_func_trace_options(*args)

def set_func_trace_options(*args) -> "void":
    r"""
    set_func_trace_options(options)


    Modify function tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param options (C++: int)
    """
    return _ida_dbg.set_func_trace_options(*args)

def request_set_func_trace_options(*args) -> "void":
    r"""
    request_set_func_trace_options(options)


    Post a 'set_func_trace_options()' request.
    
    
    @param options (C++: int)
    """
    return _ida_dbg.request_set_func_trace_options(*args)

def enable_bblk_trace(*args) -> "bool":
    r"""
    enable_bblk_trace(enable=True) -> bool
    """
    return _ida_dbg.enable_bblk_trace(*args)

def disable_bblk_trace(*args) -> "bool":
    r"""
    disable_bblk_trace() -> bool
    """
    return _ida_dbg.disable_bblk_trace(*args)

def request_enable_bblk_trace(*args) -> "bool":
    r"""
    request_enable_bblk_trace(enable=True) -> bool
    """
    return _ida_dbg.request_enable_bblk_trace(*args)

def request_disable_bblk_trace(*args) -> "bool":
    r"""
    request_disable_bblk_trace() -> bool
    """
    return _ida_dbg.request_disable_bblk_trace(*args)

def is_bblk_trace_enabled(*args) -> "bool":
    r"""
    is_bblk_trace_enabled() -> bool
    """
    return _ida_dbg.is_bblk_trace_enabled(*args)

def get_bblk_trace_options(*args) -> "int":
    r"""
    get_bblk_trace_options() -> int


    Get current basic block tracing options. Also see 'BT_LOG_INSTS'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    """
    return _ida_dbg.get_bblk_trace_options(*args)

def set_bblk_trace_options(*args) -> "void":
    r"""
    set_bblk_trace_options(options)


    Modify basic block tracing options (see 'BT_LOG_INSTS' )
    
    
    @param options (C++: int)
    """
    return _ida_dbg.set_bblk_trace_options(*args)

def request_set_bblk_trace_options(*args) -> "void":
    r"""
    request_set_bblk_trace_options(options)


    Post a 'set_bblk_trace_options()' request.
    
    
    @param options (C++: int)
    """
    return _ida_dbg.request_set_bblk_trace_options(*args)
tev_none = _ida_dbg.tev_none

tev_insn = _ida_dbg.tev_insn

tev_call = _ida_dbg.tev_call

tev_ret = _ida_dbg.tev_ret

tev_bpt = _ida_dbg.tev_bpt

tev_mem = _ida_dbg.tev_mem

tev_event = _ida_dbg.tev_event

tev_max = _ida_dbg.tev_max

class tev_info_t(object):
    r"""
    Proxy of C++ tev_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_ida_dbg.tev_info_t_type_get, _ida_dbg.tev_info_t_type_set)
    tid = property(_ida_dbg.tev_info_t_tid_get, _ida_dbg.tev_info_t_tid_set)
    ea = property(_ida_dbg.tev_info_t_ea_get, _ida_dbg.tev_info_t_ea_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> tev_info_t
        """
        _ida_dbg.tev_info_t_swiginit(self, _ida_dbg.new_tev_info_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_info_t

# Register tev_info_t in _ida_dbg:
_ida_dbg.tev_info_t_swigregister(tev_info_t)

class memreg_info_t(object):
    r"""
    Proxy of C++ memreg_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ea = property(_ida_dbg.memreg_info_t_ea_get, _ida_dbg.memreg_info_t_ea_set)

    def get_bytes(self, *args) -> "PyObject *":
        r"""
        get_bytes(self) -> PyObject *
        """
        return _ida_dbg.memreg_info_t_get_bytes(self, *args)

    bytes = property(get_bytes)


    def __init__(self, *args):
        r"""
        __init__(self) -> memreg_info_t
        """
        _ida_dbg.memreg_info_t_swiginit(self, _ida_dbg.new_memreg_info_t(*args))
    __swig_destroy__ = _ida_dbg.delete_memreg_info_t

# Register memreg_info_t in _ida_dbg:
_ida_dbg.memreg_info_t_swigregister(memreg_info_t)


def get_tev_qty(*args) -> "int":
    r"""
    get_tev_qty() -> int


    Get number of trace events available in trace buffer. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    """
    return _ida_dbg.get_tev_qty(*args)

def get_tev_info(*args) -> "bool":
    r"""
    get_tev_info(n, tev_info) -> bool


    Get main information about a trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param tev_info: result (C++: tev_info_t  *)
    @return: success
    """
    return _ida_dbg.get_tev_info(*args)

def get_insn_tev_reg_val(*args) -> "bool":
    r"""
    get_insn_tev_reg_val(n, regname, regval) -> bool


    Read a register value from an instruction trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}This
    is the value of the register before the execution of the instruction.
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param regname: name of desired register (C++: const char *)
    @param regval: result (C++: regval_t  *)
    @return: false if not an instruction event.
    """
    return _ida_dbg.get_insn_tev_reg_val(*args)

def get_insn_tev_reg_mem(*args) -> "bool":
    r"""
    get_insn_tev_reg_mem(n, memmap) -> bool


    Read the memory pointed by register values from an instruction trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param memmap: result (C++: memreg_infos_t  *)
    @return: false if not an instruction event or no memory is available
    """
    return _ida_dbg.get_insn_tev_reg_mem(*args)

def get_insn_tev_reg_result(*args) -> "bool":
    r"""
    get_insn_tev_reg_result(n, regname, regval) -> bool


    Read the resulting register value from an instruction trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param regname: name of desired register (C++: const char *)
    @param regval: result (C++: regval_t  *)
    @return: false if not an instruction trace event or register wasn't
             modified.
    """
    return _ida_dbg.get_insn_tev_reg_result(*args)

def get_call_tev_callee(*args) -> "ea_t":
    r"""
    get_call_tev_callee(n) -> ea_t


    Get the called function from a function call trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a function call event.
    """
    return _ida_dbg.get_call_tev_callee(*args)

def get_ret_tev_return(*args) -> "ea_t":
    r"""
    get_ret_tev_return(n) -> ea_t


    Get the return address from a function return trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a function return event.
    """
    return _ida_dbg.get_ret_tev_return(*args)

def get_bpt_tev_ea(*args) -> "ea_t":
    r"""
    get_bpt_tev_ea(n) -> ea_t


    Get the address associated to a read, read/write or execution trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}Usually, a breakpoint is associated with a read, read/write
    or execution trace event. However, the returned address could be any
    address in the range of this breakpoint. If the breakpoint was deleted
    after the trace event, the address no longer corresponds to a valid
    breakpoint.
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @return: BADADDR  if not a read, read/write or execution trace event.
    """
    return _ida_dbg.get_bpt_tev_ea(*args)

def get_tev_memory_info(*args) -> "bool":
    r"""
    get_tev_memory_info(n, mi) -> bool


    Get the memory layout, if any, for the specified tev object. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param mi: result (C++: meminfo_vec_t  *)
    @return: false if the tev_t object is not of type  tev_mem , true
             otherwise, with the new memory layout in "mi".
    """
    return _ida_dbg.get_tev_memory_info(*args)

def get_tev_event(*args) -> "bool":
    r"""
    get_tev_event(n, d) -> bool


    Get the corresponding debug event, if any, for the specified tev
    object. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
              represents the latest added trace event. (C++: int)
    @param d: result (C++: debug_event_t  *)
    @return: false if the tev_t object doesn't have any associated debug
             event, true otherwise, with the debug event in "d".
    """
    return _ida_dbg.get_tev_event(*args)

def get_trace_base_address(*args) -> "ea_t":
    r"""
    get_trace_base_address() -> ea_t


    Get the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @return: the base address of the currently loaded trace
    """
    return _ida_dbg.get_trace_base_address(*args)

def set_trace_base_address(*args) -> "void":
    r"""
    set_trace_base_address(ea)


    Set the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param ea (C++: ea_t)
    """
    return _ida_dbg.set_trace_base_address(*args)

def dbg_add_thread(*args) -> "void":
    r"""
    dbg_add_thread(tid)


    Add a thread to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    """
    return _ida_dbg.dbg_add_thread(*args)

def dbg_del_thread(*args) -> "void":
    r"""
    dbg_del_thread(tid)


    Delete a thread from the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    """
    return _ida_dbg.dbg_del_thread(*args)

def dbg_add_tev(*args) -> "void":
    r"""
    dbg_add_tev(type, tid, address)


    Add a new trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param type (C++: tev_type_t)
    @param tid (C++: thid_t)
    @param address (C++: ea_t)
    """
    return _ida_dbg.dbg_add_tev(*args)
class tev_reg_value_t(object):
    r"""
    Proxy of C++ tev_reg_value_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = property(_ida_dbg.tev_reg_value_t_value_get, _ida_dbg.tev_reg_value_t_value_set)
    reg_idx = property(_ida_dbg.tev_reg_value_t_reg_idx_get, _ida_dbg.tev_reg_value_t_reg_idx_set)

    def __init__(self, *args):
        r"""
        __init__(self, _reg_idx=-1, _value=uint64(-1)) -> tev_reg_value_t
        """
        _ida_dbg.tev_reg_value_t_swiginit(self, _ida_dbg.new_tev_reg_value_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_reg_value_t

# Register tev_reg_value_t in _ida_dbg:
_ida_dbg.tev_reg_value_t_swigregister(tev_reg_value_t)

class tev_info_reg_t(object):
    r"""
    Proxy of C++ tev_info_reg_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    info = property(_ida_dbg.tev_info_reg_t_info_get, _ida_dbg.tev_info_reg_t_info_set)
    registers = property(_ida_dbg.tev_info_reg_t_registers_get, _ida_dbg.tev_info_reg_t_registers_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> tev_info_reg_t
        """
        _ida_dbg.tev_info_reg_t_swiginit(self, _ida_dbg.new_tev_info_reg_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_info_reg_t

# Register tev_info_reg_t in _ida_dbg:
_ida_dbg.tev_info_reg_t_swigregister(tev_info_reg_t)

SAVE_ALL_VALUES = _ida_dbg.SAVE_ALL_VALUES

SAVE_DIFF = _ida_dbg.SAVE_DIFF

SAVE_NONE = _ida_dbg.SAVE_NONE


def dbg_add_many_tevs(*args) -> "bool":
    r"""
    dbg_add_many_tevs(new_tevs) -> bool


    Add many new trace elements to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param new_tevs (C++: tevinforeg_vec_t  *)
    @return: false if the operation failed for any  tev_info_t  object
    """
    return _ida_dbg.dbg_add_many_tevs(*args)

def dbg_add_insn_tev(*args) -> "bool":
    r"""
    dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -> bool


    Add a new instruction trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param ea (C++: ea_t)
    @param save (C++: save_reg_values_t)
    @return: false if the operation failed, true otherwise
    """
    return _ida_dbg.dbg_add_insn_tev(*args)

def dbg_add_bpt_tev(*args) -> "bool":
    r"""
    dbg_add_bpt_tev(tid, ea, bp) -> bool


    Add a new breakpoint trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param ea (C++: ea_t)
    @param bp (C++: ea_t)
    @return: false if the operation failed, true otherwise
    """
    return _ida_dbg.dbg_add_bpt_tev(*args)

def dbg_add_call_tev(*args) -> "void":
    r"""
    dbg_add_call_tev(tid, caller, callee)


    Add a new call trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param caller (C++: ea_t)
    @param callee (C++: ea_t)
    """
    return _ida_dbg.dbg_add_call_tev(*args)

def dbg_add_ret_tev(*args) -> "void":
    r"""
    dbg_add_ret_tev(tid, ret_insn, return_to)


    Add a new return trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param tid (C++: thid_t)
    @param ret_insn (C++: ea_t)
    @param return_to (C++: ea_t)
    """
    return _ida_dbg.dbg_add_ret_tev(*args)

def dbg_add_debug_event(*args) -> "void":
    r"""
    dbg_add_debug_event(event)


    Add a new debug event to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param event (C++: debug_event_t  *)
    """
    return _ida_dbg.dbg_add_debug_event(*args)

def load_trace_file(*args) -> "qstring *":
    r"""
    load_trace_file(filename) -> str


    Load a recorded trace file in the trace window. If the call succeeds
    and 'buf' is not null, the description of the trace stored in the
    binary trace file will be returned in 'buf'
    
    @param filename (C++: const char *)
    """
    return _ida_dbg.load_trace_file(*args)

def save_trace_file(*args) -> "bool":
    r"""
    save_trace_file(filename, description) -> bool


    Save the current trace in the specified file.
    
    
    @param filename (C++: const char *)
    @param description (C++: const char *)
    """
    return _ida_dbg.save_trace_file(*args)

def is_valid_trace_file(*args) -> "bool":
    r"""
    is_valid_trace_file(filename) -> bool


    Is the specified file a valid trace file for the current database?
    
    
    @param filename (C++: const char *)
    """
    return _ida_dbg.is_valid_trace_file(*args)

def set_trace_file_desc(*args) -> "bool":
    r"""
    set_trace_file_desc(filename, description) -> bool


    Change the description of the specified trace file.
    
    
    @param filename (C++: const char *)
    @param description (C++: const char *)
    """
    return _ida_dbg.set_trace_file_desc(*args)

def get_trace_file_desc(*args) -> "qstring *":
    r"""
    get_trace_file_desc(filename) -> str


    Get the file header of the specified trace file.
    
    
    @param filename (C++: const char *)
    """
    return _ida_dbg.get_trace_file_desc(*args)

def choose_trace_file(*args) -> "qstring *":
    r"""
    choose_trace_file() -> str


    Show the choose trace dialog.
    """
    return _ida_dbg.choose_trace_file(*args)

def graph_trace(*args) -> "bool":
    r"""
    graph_trace() -> bool


    Show the trace callgraph.
    """
    return _ida_dbg.graph_trace(*args)

def set_highlight_trace_options(*args) -> "void":
    r"""
    set_highlight_trace_options(hilight, color, diff)


    Set highlight trace parameters.
    
    
    @param hilight (C++: bool)
    @param color (C++: bgcolor_t)
    @param diff (C++: bgcolor_t)
    """
    return _ida_dbg.set_highlight_trace_options(*args)

def set_trace_platform(*args) -> "void":
    r"""
    set_trace_platform(platform)


    Set platform name of current trace.
    
    
    @param platform (C++: const char *)
    """
    return _ida_dbg.set_trace_platform(*args)

def get_trace_platform(*args) -> "char const *":
    r"""
    get_trace_platform() -> char const *


    Get platform name of current trace.
    """
    return _ida_dbg.get_trace_platform(*args)
DEC_NOTASK = _ida_dbg.DEC_NOTASK

DEC_ERROR = _ida_dbg.DEC_ERROR

DEC_TIMEOUT = _ida_dbg.DEC_TIMEOUT

WFNE_ANY = _ida_dbg.WFNE_ANY
"""
return the first event (even if it doesn't suspend the process)
"""

WFNE_SUSP = _ida_dbg.WFNE_SUSP
"""
wait until the process gets suspended
"""

WFNE_SILENT = _ida_dbg.WFNE_SILENT
"""
1: be slient, 0:display modal boxes if necessary
"""

WFNE_CONT = _ida_dbg.WFNE_CONT
"""
continue from the suspended state
"""

WFNE_NOWAIT = _ida_dbg.WFNE_NOWAIT
"""
(to be used with 'WFNE_CONT' )

do not wait for any event, immediately return 'DEC_TIMEOUT'
"""

WFNE_USEC = _ida_dbg.WFNE_USEC
"""
(minimum non-zero timeout is 40000us)

timeout is specified in microseconds
"""

DOPT_SEGM_MSGS = _ida_dbg.DOPT_SEGM_MSGS
"""
log debugger segments modifications
"""

DOPT_START_BPT = _ida_dbg.DOPT_START_BPT
"""
break on process start
"""

DOPT_THREAD_MSGS = _ida_dbg.DOPT_THREAD_MSGS
"""
log thread starts/exits
"""

DOPT_THREAD_BPT = _ida_dbg.DOPT_THREAD_BPT
"""
break on thread start/exit
"""

DOPT_BPT_MSGS = _ida_dbg.DOPT_BPT_MSGS
"""
log breakpoints
"""

DOPT_LIB_MSGS = _ida_dbg.DOPT_LIB_MSGS
"""
log library loads/unloads
"""

DOPT_LIB_BPT = _ida_dbg.DOPT_LIB_BPT
"""
break on library load/unload
"""

DOPT_INFO_MSGS = _ida_dbg.DOPT_INFO_MSGS
"""
log debugging info events
"""

DOPT_INFO_BPT = _ida_dbg.DOPT_INFO_BPT
"""
break on debugging information
"""

DOPT_REAL_MEMORY = _ida_dbg.DOPT_REAL_MEMORY
"""
do not hide breakpoint instructions
"""

DOPT_REDO_STACK = _ida_dbg.DOPT_REDO_STACK
"""
reconstruct the stack
"""

DOPT_ENTRY_BPT = _ida_dbg.DOPT_ENTRY_BPT
"""
break on program entry point
"""

DOPT_EXCDLG = _ida_dbg.DOPT_EXCDLG
"""
exception dialogs:
"""

EXCDLG_NEVER = _ida_dbg.EXCDLG_NEVER
"""
never display exception dialogs
"""

EXCDLG_UNKNOWN = _ida_dbg.EXCDLG_UNKNOWN
"""
display for unknown exceptions
"""

EXCDLG_ALWAYS = _ida_dbg.EXCDLG_ALWAYS
"""
always display
"""

DOPT_LOAD_DINFO = _ida_dbg.DOPT_LOAD_DINFO
"""
automatically load debug files (pdb)
"""

DOPT_END_BPT = _ida_dbg.DOPT_END_BPT
"""
evaluate event condition on process end
"""

DOPT_TEMP_HWBPT = _ida_dbg.DOPT_TEMP_HWBPT
"""
when possible use hardware bpts for temp bpts
"""


def wait_for_next_event(*args) -> "dbg_event_code_t":
    r"""
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t


    Wait for the next event.This function (optionally) resumes the process
    execution, and waits for a debugger event until a possible timeout
    occurs.
    
    @param wfne: combination of  Wait for debugger event flags  constants
                 (C++: int)
    @param timeout: number of seconds to wait, -1-infinity (C++: int)
    @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
             0)
    """
    return _ida_dbg.wait_for_next_event(*args)

def get_debug_event(*args) -> "debug_event_t const *":
    r"""
    get_debug_event() -> debug_event_t


    Get the current debugger event.
    """
    return _ida_dbg.get_debug_event(*args)

def set_debugger_options(*args) -> "uint":
    r"""
    set_debugger_options(options) -> uint


    Set debugger options. Replaces debugger options with the specification
    combination 'Debugger options'
    
    @param options (C++: uint)
    @return: the old debugger options
    """
    return _ida_dbg.set_debugger_options(*args)

def set_remote_debugger(*args) -> "void":
    r"""
    set_remote_debugger(host, _pass, port=-1)


    Set remote debugging options. Should be used before starting the
    debugger.
    
    @param host: If empty, IDA will use local debugger. If NULL, the host
                 will not be set. (C++: const char *)
    @param port: If -1, the default port number will be used (C++: int)
    """
    return _ida_dbg.set_remote_debugger(*args)

def get_process_options(*args) -> "void":
    r"""
    get_process_options(path, args, sdir, host, _pass, port)


    Get process options. Any of the arguments may be NULL
    
    @param path (C++: qstring  *)
    @param args (C++: qstring  *)
    @param sdir (C++: qstring  *)
    @param host (C++: qstring  *)
    @param port (C++: int *)
    """
    return _ida_dbg.get_process_options(*args)

def set_process_options(*args) -> "void":
    r"""
    set_process_options(path, args, sdir, host, _pass, port)


    Set process options. Any of the arguments may be NULL, which means 'do
    not modify'
    
    @param path (C++: const char *)
    @param args (C++: const char *)
    @param sdir (C++: const char *)
    @param host (C++: const char *)
    @param port (C++: int)
    """
    return _ida_dbg.set_process_options(*args)

def retrieve_exceptions(*args) -> "excvec_t *":
    r"""
    retrieve_exceptions() -> excvec_t


    Retrieve the exception information. You may freely modify the returned
    vector and add/edit/delete exceptions You must call
    'store_exceptions()' after any modifications Note: exceptions with
    code zero, multiple exception codes or names are prohibited
    """
    return _ida_dbg.retrieve_exceptions(*args)

def store_exceptions(*args) -> "bool":
    r"""
    store_exceptions() -> bool


    Update the exception information stored in the debugger module by
    invoking its dbg->set_exception_info callback
    """
    return _ida_dbg.store_exceptions(*args)

def define_exception(*args) -> "char const *":
    r"""
    define_exception(code, name, desc, flags) -> char const *


    Convenience function: define new exception code.
    
    @param code: exception code (cannot be 0) (C++: uint)
    @param name: exception name (cannot be empty or NULL) (C++: const char
                 *)
    @param desc: exception description (maybe NULL) (C++: const char *)
    @param flags: combination of  Exception info flags (C++: int)
    @return: failure message or NULL. You must call  store_exceptions()
             if this function succeeds
    """
    return _ida_dbg.define_exception(*args)
class eval_ctx_t(object):
    r"""
    Proxy of C++ eval_ctx_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, _ea) -> eval_ctx_t
        """
        _ida_dbg.eval_ctx_t_swiginit(self, _ida_dbg.new_eval_ctx_t(*args))
    ea = property(_ida_dbg.eval_ctx_t_ea_get, _ida_dbg.eval_ctx_t_ea_set)
    __swig_destroy__ = _ida_dbg.delete_eval_ctx_t

# Register eval_ctx_t in _ida_dbg:
_ida_dbg.eval_ctx_t_swigregister(eval_ctx_t)

SRCIT_NONE = _ida_dbg.SRCIT_NONE

SRCIT_MODULE = _ida_dbg.SRCIT_MODULE

SRCIT_FUNC = _ida_dbg.SRCIT_FUNC

SRCIT_STMT = _ida_dbg.SRCIT_STMT

SRCIT_EXPR = _ida_dbg.SRCIT_EXPR

SRCIT_STTVAR = _ida_dbg.SRCIT_STTVAR

SRCIT_LOCVAR = _ida_dbg.SRCIT_LOCVAR

SRCDBG_PROV_VERSION = _ida_dbg.SRCDBG_PROV_VERSION


def create_source_viewer(*args) -> "source_view_t *":
    r"""
    create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -> source_view_t *


    Create a source code view.
    
    
    @param out_ccv (C++: TWidget **)
    @param parent (C++: TWidget *)
    @param custview (C++: TWidget *)
    @param sf (C++: source_file_ptr)
    @param lines (C++: strvec_t  *)
    @param lnnum (C++: int)
    @param colnum (C++: int)
    @param flags (C++: int)
    """
    return _ida_dbg.create_source_viewer(*args)

def get_dbg_byte(*args) -> "bool":
    r"""
    get_dbg_byte(x, ea) -> bool


    Get one byte of the debugged process memory.
    
    @param x: pointer to byte value (C++: uint32  *)
    @param ea: linear address (C++: ea_t)
    @return: true success
    """
    return _ida_dbg.get_dbg_byte(*args)

def put_dbg_byte(*args) -> "bool":
    r"""
    put_dbg_byte(ea, x) -> bool


    Change one byte of the debugged process memory.
    
    @param ea: linear address (C++: ea_t)
    @param x: byte value (C++: uint32)
    @return: true if the process memory has been modified
    """
    return _ida_dbg.put_dbg_byte(*args)

def invalidate_dbgmem_config(*args) -> "void":
    r"""
    invalidate_dbgmem_config()


    Invalidate the debugged process memory configuration. Call this
    function if the debugged process might have changed its memory layout
    (allocated more memory, for example)
    """
    return _ida_dbg.invalidate_dbgmem_config(*args)

def invalidate_dbgmem_contents(*args) -> "void":
    r"""
    invalidate_dbgmem_contents(ea, size)


    Invalidate the debugged process memory contents. Call this function
    each time the process has been stopped or the process memory is
    modified. If ea == 'BADADDR' , then the whole memory contents will be
    invalidated
    
    @param ea (C++: ea_t)
    @param size (C++: asize_t)
    """
    return _ida_dbg.invalidate_dbgmem_contents(*args)

def is_debugger_on(*args) -> "bool":
    r"""
    is_debugger_on() -> bool


    Is the debugger currently running?
    """
    return _ida_dbg.is_debugger_on(*args)

def is_debugger_memory(*args) -> "bool":
    r"""
    is_debugger_memory(ea) -> bool


    Is the address mapped to debugger memory?
    
    
    @param ea (C++: ea_t)
    """
    return _ida_dbg.is_debugger_memory(*args)

def get_tev_ea(*args) -> "ea_t":
    r"""
    get_tev_ea(n) -> ea_t
    """
    return _ida_dbg.get_tev_ea(*args)

def get_tev_type(*args) -> "int":
    r"""
    get_tev_type(n) -> int
    """
    return _ida_dbg.get_tev_type(*args)

def get_tev_tid(*args) -> "int":
    r"""
    get_tev_tid(n) -> int
    """
    return _ida_dbg.get_tev_tid(*args)

def get_module_info(*args) -> "bool":
    r"""
    get_module_info(ea, modinfo) -> bool
    """
    return _ida_dbg.get_module_info(*args)

def bring_debugger_to_front(*args) -> "void":
    r"""
    bring_debugger_to_front()
    """
    return _ida_dbg.bring_debugger_to_front(*args)

def collect_stack_trace(*args) -> "bool":
    r"""
    collect_stack_trace(tid, trace) -> bool
    """
    return _ida_dbg.collect_stack_trace(*args)

def get_debugger_event_cond(*args) -> "char const *":
    r"""
    get_debugger_event_cond() -> char const *
    """
    return _ida_dbg.get_debugger_event_cond(*args)

def load_debugger(*args) -> "bool":
    r"""
    load_debugger(dbgname, use_remote) -> bool
    """
    return _ida_dbg.load_debugger(*args)

def set_manual_regions(*args) -> "void":
    r"""
    set_manual_regions(ranges)
    """
    return _ida_dbg.set_manual_regions(*args)

def edit_manual_regions(*args) -> "void":
    r"""
    edit_manual_regions()
    """
    return _ida_dbg.edit_manual_regions(*args)

def enable_manual_regions(*args) -> "void":
    r"""
    enable_manual_regions(enable)
    """
    return _ida_dbg.enable_manual_regions(*args)

def hide_all_bpts(*args) -> "int":
    r"""
    hide_all_bpts() -> int
    """
    return _ida_dbg.hide_all_bpts(*args)

def handle_debug_event(*args) -> "int":
    r"""
    handle_debug_event(ev, rqflags) -> int
    """
    return _ida_dbg.handle_debug_event(*args)

def add_virt_module(*args) -> "bool":
    r"""
    add_virt_module(mod) -> bool
    """
    return _ida_dbg.add_virt_module(*args)

def del_virt_module(*args) -> "bool":
    r"""
    del_virt_module(base) -> bool
    """
    return _ida_dbg.del_virt_module(*args)

def internal_ioctl(*args) -> "int":
    r"""
    internal_ioctl(fn, buf, poutbuf, poutsize) -> int
    """
    return _ida_dbg.internal_ioctl(*args)

def read_dbg_memory(*args) -> "ssize_t":
    r"""
    read_dbg_memory(ea, buffer, size) -> ssize_t
    """
    return _ida_dbg.read_dbg_memory(*args)

def get_reg_vals(*args) -> "int":
    r"""
    get_reg_vals(tid, clsmask, values) -> int
    """
    return _ida_dbg.get_reg_vals(*args)

def get_dbg_memory_info(*args) -> "int":
    r"""
    get_dbg_memory_info(ranges) -> int
    """
    return _ida_dbg.get_dbg_memory_info(*args)

def set_bpt_group(*args) -> "void":
    r"""
    set_bpt_group(bpt, grp_name)
    """
    return _ida_dbg.set_bpt_group(*args)

def set_bptloc_group(*args) -> "bool":
    r"""
    set_bptloc_group(bptloc, grp_name) -> bool
    """
    return _ida_dbg.set_bptloc_group(*args)

def get_bpt_group(*args) -> "qstring *":
    r"""
    get_bpt_group(bptloc) -> str
    """
    return _ida_dbg.get_bpt_group(*args)

def rename_bptgrp(*args) -> "bool":
    r"""
    rename_bptgrp(old_name, new_name) -> bool
    """
    return _ida_dbg.rename_bptgrp(*args)

def del_bptgrp(*args) -> "bool":
    r"""
    del_bptgrp(name) -> bool
    """
    return _ida_dbg.del_bptgrp(*args)

def get_grp_bpts(*args) -> "ssize_t":
    r"""
    get_grp_bpts(bpts, grp_name) -> ssize_t
    """
    return _ida_dbg.get_grp_bpts(*args)

def get_srcinfo_provider(*args) -> "srcinfo_provider_t *":
    r"""
    get_srcinfo_provider(name) -> srcinfo_provider_t *
    """
    return _ida_dbg.get_srcinfo_provider(*args)

def get_global_var(*args) -> "bool":
    r"""
    get_global_var(prov, ea, name, out) -> bool
    """
    return _ida_dbg.get_global_var(*args)

def get_local_var(*args) -> "bool":
    r"""
    get_local_var(prov, ea, name, out) -> bool
    """
    return _ida_dbg.get_local_var(*args)

def get_local_vars(*args) -> "bool":
    r"""
    get_local_vars(prov, ea, out) -> bool
    """
    return _ida_dbg.get_local_vars(*args)

def add_path_mapping(*args) -> "void":
    r"""
    add_path_mapping(src, dst)
    """
    return _ida_dbg.add_path_mapping(*args)

def get_current_source_file(*args) -> "bool":
    r"""
    get_current_source_file(path) -> bool
    """
    return _ida_dbg.get_current_source_file(*args)

def get_current_source_line(*args) -> "int":
    r"""
    get_current_source_line() -> int
    """
    return _ida_dbg.get_current_source_line(*args)

def srcdbg_step_into(*args) -> "bool":
    r"""
    srcdbg_step_into() -> bool
    """
    return _ida_dbg.srcdbg_step_into(*args)

def srcdbg_request_step_into(*args) -> "bool":
    r"""
    srcdbg_request_step_into() -> bool
    """
    return _ida_dbg.srcdbg_request_step_into(*args)

def srcdbg_step_over(*args) -> "bool":
    r"""
    srcdbg_step_over() -> bool
    """
    return _ida_dbg.srcdbg_step_over(*args)

def srcdbg_request_step_over(*args) -> "bool":
    r"""
    srcdbg_request_step_over() -> bool
    """
    return _ida_dbg.srcdbg_request_step_over(*args)

def srcdbg_step_until_ret(*args) -> "bool":
    r"""
    srcdbg_step_until_ret() -> bool
    """
    return _ida_dbg.srcdbg_step_until_ret(*args)

def srcdbg_request_step_until_ret(*args) -> "bool":
    r"""
    srcdbg_request_step_until_ret() -> bool
    """
    return _ida_dbg.srcdbg_request_step_until_ret(*args)

def dbg_bin_search(*args) -> "uint64 *, qstring *":
    r"""
    dbg_bin_search(start_ea, end_ea, data, srch_flags) -> str
    """
    return _ida_dbg.dbg_bin_search(*args)

def dbg_can_query(*args) -> "bool":
    r"""
    dbg_can_query() -> bool


    This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    @return: Boolean
    """
    return _ida_dbg.dbg_can_query(*args)

def get_manual_regions(*args) -> "PyObject *":
    r"""
    get_manual_regions(ranges)
    get_manual_regions() -> PyObject *


    Returns the manual memory regions
    @return: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)
    """
    return _ida_dbg.get_manual_regions(*args)

def dbg_is_loaded(*args) -> "bool":
    r"""
    dbg_is_loaded() -> bool


    Checks if a debugger is loaded
    @return: Boolean
    """
    return _ida_dbg.dbg_is_loaded(*args)

def refresh_debugger_memory(*args) -> "PyObject *":
    r"""
    refresh_debugger_memory() -> PyObject *


    Refreshes the debugger memory
    @return: Nothing
    """
    return _ida_dbg.refresh_debugger_memory(*args)
class DBG_Hooks(object):
    r"""
    Proxy of C++ DBG_Hooks class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, _flags=0) -> DBG_Hooks
        """
        if self.__class__ == DBG_Hooks:
            _self = None
        else:
            _self = self
        _ida_dbg.DBG_Hooks_swiginit(self, _ida_dbg.new_DBG_Hooks(_self, *args))

    def hook(self, *args) -> "bool":
        r"""
        hook(self) -> bool
        """
        return _ida_dbg.DBG_Hooks_hook(self, *args)

    def unhook(self, *args) -> "bool":
        r"""
        unhook(self) -> bool
        """
        return _ida_dbg.DBG_Hooks_unhook(self, *args)

    def dbg_process_start(self, *args) -> "void":
        r"""
        dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
        """
        return _ida_dbg.DBG_Hooks_dbg_process_start(self, *args)

    def dbg_process_exit(self, *args) -> "void":
        r"""
        dbg_process_exit(self, pid, tid, ea, exit_code)
        """
        return _ida_dbg.DBG_Hooks_dbg_process_exit(self, *args)

    def dbg_process_attach(self, *args) -> "void":
        r"""
        dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
        """
        return _ida_dbg.DBG_Hooks_dbg_process_attach(self, *args)

    def dbg_process_detach(self, *args) -> "void":
        r"""
        dbg_process_detach(self, pid, tid, ea)
        """
        return _ida_dbg.DBG_Hooks_dbg_process_detach(self, *args)

    def dbg_thread_start(self, *args) -> "void":
        r"""
        dbg_thread_start(self, pid, tid, ea)
        """
        return _ida_dbg.DBG_Hooks_dbg_thread_start(self, *args)

    def dbg_thread_exit(self, *args) -> "void":
        r"""
        dbg_thread_exit(self, pid, tid, ea, exit_code)
        """
        return _ida_dbg.DBG_Hooks_dbg_thread_exit(self, *args)

    def dbg_library_load(self, *args) -> "void":
        r"""
        dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
        """
        return _ida_dbg.DBG_Hooks_dbg_library_load(self, *args)

    def dbg_library_unload(self, *args) -> "void":
        r"""
        dbg_library_unload(self, pid, tid, ea, info)
        """
        return _ida_dbg.DBG_Hooks_dbg_library_unload(self, *args)

    def dbg_information(self, *args) -> "void":
        r"""
        dbg_information(self, pid, tid, ea, info)
        """
        return _ida_dbg.DBG_Hooks_dbg_information(self, *args)

    def dbg_exception(self, *args) -> "int":
        r"""
        dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -> int
        """
        return _ida_dbg.DBG_Hooks_dbg_exception(self, *args)

    def dbg_suspend_process(self, *args) -> "void":
        r"""
        dbg_suspend_process(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_suspend_process(self, *args)

    def dbg_bpt(self, *args) -> "int":
        r"""
        dbg_bpt(self, tid, bptea) -> int
        """
        return _ida_dbg.DBG_Hooks_dbg_bpt(self, *args)

    def dbg_trace(self, *args) -> "int":
        r"""
        dbg_trace(self, tid, ip) -> int
        """
        return _ida_dbg.DBG_Hooks_dbg_trace(self, *args)

    def dbg_request_error(self, *args) -> "void":
        r"""
        dbg_request_error(self, failed_command, failed_dbg_notification)
        """
        return _ida_dbg.DBG_Hooks_dbg_request_error(self, *args)

    def dbg_step_into(self, *args) -> "void":
        r"""
        dbg_step_into(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_step_into(self, *args)

    def dbg_step_over(self, *args) -> "void":
        r"""
        dbg_step_over(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_step_over(self, *args)

    def dbg_run_to(self, *args) -> "void":
        r"""
        dbg_run_to(self, pid, tid, ea)
        """
        return _ida_dbg.DBG_Hooks_dbg_run_to(self, *args)

    def dbg_step_until_ret(self, *args) -> "void":
        r"""
        dbg_step_until_ret(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_step_until_ret(self, *args)

    def dbg_bpt_changed(self, *args) -> "void":
        r"""
        dbg_bpt_changed(self, bptev_code, bpt)
        """
        return _ida_dbg.DBG_Hooks_dbg_bpt_changed(self, *args)

    def dbg_started_loading_bpts(self, *args) -> "void":
        r"""
        dbg_started_loading_bpts(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_started_loading_bpts(self, *args)

    def dbg_finished_loading_bpts(self, *args) -> "void":
        r"""
        dbg_finished_loading_bpts(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_finished_loading_bpts(self, *args)
    __swig_destroy__ = _ida_dbg.delete_DBG_Hooks
    def __disown__(self):
        self.this.disown()
        _ida_dbg.disown_DBG_Hooks(self)
        return weakref.proxy(self)

# Register DBG_Hooks in _ida_dbg:
_ida_dbg.DBG_Hooks_swigregister(DBG_Hooks)


def list_bptgrps(*args) -> "PyObject *":
    r"""
    list_bptgrps(bptgrps) -> size_t
    list_bptgrps() -> PyObject *
    """
    return _ida_dbg.list_bptgrps(*args)

def move_bpt_to_grp(*args) -> "void":
    r"""
    move_bpt_to_grp(bpt, grp_name)


    Sets new group for the breakpoint
    """
    return _ida_dbg.move_bpt_to_grp(*args)

def internal_get_sreg_base(*args) -> "ea_t":
    r"""
    internal_get_sreg_base(tid, sreg_value) -> ea_t


    Get the sreg base, for the given thread.
    
    @return: The sreg base, or BADADDR on failure.
    """
    return _ida_dbg.internal_get_sreg_base(*args)

def write_dbg_memory(*args) -> "ssize_t":
    r"""
    write_dbg_memory(ea, py_buf, size=size_t(-1)) -> ssize_t
    """
    return _ida_dbg.write_dbg_memory(*args)

def set_reg_val(*args) -> "PyObject *":
    r"""
    set_reg_val(regname, o) -> PyObject
    set_reg_val(tid, regidx, o) -> PyObject *


    Write a register value to the current thread. \sq{Type, Synchronous
    function - available as Request, Notification, none (synchronous
    function)}
    
    @param regname (C++: const char *)
    """
    return _ida_dbg.set_reg_val(*args)

def request_set_reg_val(*args) -> "PyObject *":
    r"""
    request_set_reg_val(regname, o) -> PyObject *


    Post a 'set_reg_val()' request.
    
    
    @param regname (C++: const char *)
    """
    return _ida_dbg.request_set_reg_val(*args)

def get_reg_val(*args) -> "PyObject *":
    r"""
    get_reg_val(regname, regval) -> bool
    get_reg_val(regname, ival) -> bool
    get_reg_val(regname) -> PyObject *


    Read a register value from the current thread. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname (C++: const char *)
    @param regval (C++: regval_t  *)
    """
    return _ida_dbg.get_reg_val(*args)

#<pycode(py_dbg)>
import ida_idaapi
import ida_idd
import ida_expr

def get_tev_reg_val(tev, reg):
    rv = ida_idd.regval_t()
    if get_insn_tev_reg_val(tev, reg, rv):
        if rv.rvtype == ida_idd.RVT_INT:
            return rv.ival

def get_tev_reg_mem_qty(tev):
    ti = tev_info_t()
    if get_tev_info(tev, ti):
        mis = memreg_infos_t()
        if get_insn_tev_reg_mem(tev, mis):
            return mis.size()

def get_tev_reg_mem(tev, idx):
    mis = memreg_infos_t()
    if get_insn_tev_reg_mem(tev, mis):
        if idx < mis.size():
            return mis[idx].bytes

def get_tev_reg_mem_ea(tev, idx):
    ti = tev_info_t()
    if get_tev_info(tev, ti):
        mis = memreg_infos_t()
        if get_insn_tev_reg_mem(tev, mis):
            if idx >= 0 and idx < mis.size():
                return mis[idx].ea

def send_dbg_command(command):
    """
    Send a direct command to the debugger backend, and
    retrieve the result as a string.

    Note: any double-quotes in 'command' must be backslash-escaped.
    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.

    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure
    """
    rv = ida_expr.idc_value_t()
    err = ida_expr.eval_idc_expr(rv, ida_idaapi.BADADDR, """send_dbg_command("%s");""" % command)
    if err:
        return False, "eval_idc_expr() failed: %s" % err
    vtype = ord(rv.vtype)
    if vtype == ida_expr.VT_STR:
        s = rv.c_str()
        if "IDC_FAILURE" in s:
            return False, "eval_idc_expr() reported an error: %s" % s
        return True, s
    elif vtype == ida_expr.VT_LONG:
        return True, str(rv.num)
    else:
        return False, "eval_idc_expr(): wrong return type: %d" % vtype

#</pycode(py_dbg)>


if _BC695:
    import ida_idd
    def get_process_info(n, pi):
        pis = ida_idd.procinfo_vec_t()
        cnt = get_processes(pis)
        if n >= cnt:
            return ida_idd.NO_PROCESS
        pi.name = pis[n].name
        pi.pid = pis[n].pid
        return pi.pid
    def get_process_qty():
        pis = ida_idd.procinfo_vec_t()
        return get_processes(pis)



