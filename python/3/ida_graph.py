# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: graph
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_graph
else:
    import _ida_graph

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_graph.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class screen_graph_selection_base_t(object):
    r"""
    Proxy of C++ qvector< selection_item_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> screen_graph_selection_base_t
        __init__(self, x) -> screen_graph_selection_base_t
        """
        _ida_graph.screen_graph_selection_base_t_swiginit(self, _ida_graph.new_screen_graph_selection_base_t(*args))
    __swig_destroy__ = _ida_graph.delete_screen_graph_selection_base_t

    def push_back(self, *args) -> "selection_item_t &":
        r"""
        push_back(self, x)
        push_back(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_graph.screen_graph_selection_base_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_base_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t_empty(self, *args)

    def at(self, *args) -> "selection_item_t const &":
        r"""
        at(self, _idx) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_graph.screen_graph_selection_base_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_graph.screen_graph_selection_base_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_graph.screen_graph_selection_base_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, x=selection_item_t())
        """
        return _ida_graph.screen_graph_selection_base_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_base_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""
        reserve(self, cnt)
        """
        return _ida_graph.screen_graph_selection_base_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_graph.screen_graph_selection_base_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""
        swap(self, r)
        """
        return _ida_graph.screen_graph_selection_base_t_swap(self, *args)

    def extract(self, *args) -> "selection_item_t *":
        r"""
        extract(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""
        inject(self, s, len)
        """
        return _ida_graph.screen_graph_selection_base_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< selection_item_t >::const_iterator":
        r"""
        begin(self) -> selection_item_t
        begin(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_begin(self, *args)

    def end(self, *args) -> "qvector< selection_item_t >::const_iterator":
        r"""
        end(self) -> selection_item_t
        end(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_end(self, *args)

    def insert(self, *args) -> "qvector< selection_item_t >::iterator":
        r"""
        insert(self, it, x) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_insert(self, *args)

    def erase(self, *args) -> "qvector< selection_item_t >::iterator":
        r"""
        erase(self, it) -> selection_item_t
        erase(self, first, last) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_erase(self, *args)

    def find(self, *args) -> "qvector< selection_item_t >::const_iterator":
        r"""
        find(self, x) -> selection_item_t
        find(self, x) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""
        has(self, x) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""
        add_unique(self, x) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""
        _del(self, x) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_base_t___len__(self, *args)

    def __getitem__(self, *args) -> "selection_item_t const &":
        r"""
        __getitem__(self, i) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, i, v)
        """
        return _ida_graph.screen_graph_selection_base_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register screen_graph_selection_base_t in _ida_graph:
_ida_graph.screen_graph_selection_base_t_swigregister(screen_graph_selection_base_t)

class node_layout_t(object):
    r"""
    Proxy of C++ qvector< rect_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> node_layout_t
        __init__(self, x) -> node_layout_t
        """
        _ida_graph.node_layout_t_swiginit(self, _ida_graph.new_node_layout_t(*args))
    __swig_destroy__ = _ida_graph.delete_node_layout_t

    def push_back(self, *args) -> "rect_t &":
        r"""
        push_back(self, x)
        push_back(self) -> rect_t
        """
        return _ida_graph.node_layout_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_graph.node_layout_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_graph.node_layout_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_graph.node_layout_t_empty(self, *args)

    def at(self, *args) -> "rect_t const &":
        r"""
        at(self, _idx) -> rect_t
        """
        return _ida_graph.node_layout_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_graph.node_layout_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_graph.node_layout_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_graph.node_layout_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, x=rect_t())
        """
        return _ida_graph.node_layout_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_graph.node_layout_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""
        reserve(self, cnt)
        """
        return _ida_graph.node_layout_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_graph.node_layout_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""
        swap(self, r)
        """
        return _ida_graph.node_layout_t_swap(self, *args)

    def extract(self, *args) -> "rect_t *":
        r"""
        extract(self) -> rect_t
        """
        return _ida_graph.node_layout_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""
        inject(self, s, len)
        """
        return _ida_graph.node_layout_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.node_layout_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.node_layout_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< rect_t >::const_iterator":
        r"""
        begin(self) -> rect_t
        begin(self) -> rect_t
        """
        return _ida_graph.node_layout_t_begin(self, *args)

    def end(self, *args) -> "qvector< rect_t >::const_iterator":
        r"""
        end(self) -> rect_t
        end(self) -> rect_t
        """
        return _ida_graph.node_layout_t_end(self, *args)

    def insert(self, *args) -> "qvector< rect_t >::iterator":
        r"""
        insert(self, it, x) -> rect_t
        """
        return _ida_graph.node_layout_t_insert(self, *args)

    def erase(self, *args) -> "qvector< rect_t >::iterator":
        r"""
        erase(self, it) -> rect_t
        erase(self, first, last) -> rect_t
        """
        return _ida_graph.node_layout_t_erase(self, *args)

    def find(self, *args) -> "qvector< rect_t >::const_iterator":
        r"""
        find(self, x) -> rect_t
        find(self, x) -> rect_t
        """
        return _ida_graph.node_layout_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""
        has(self, x) -> bool
        """
        return _ida_graph.node_layout_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""
        add_unique(self, x) -> bool
        """
        return _ida_graph.node_layout_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""
        _del(self, x) -> bool
        """
        return _ida_graph.node_layout_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_graph.node_layout_t___len__(self, *args)

    def __getitem__(self, *args) -> "rect_t const &":
        r"""
        __getitem__(self, i) -> rect_t
        """
        return _ida_graph.node_layout_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, i, v)
        """
        return _ida_graph.node_layout_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register node_layout_t in _ida_graph:
_ida_graph.node_layout_t_swigregister(node_layout_t)

class pointvec_t(object):
    r"""
    Proxy of C++ qvector< point_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> pointvec_t
        __init__(self, x) -> pointvec_t
        """
        _ida_graph.pointvec_t_swiginit(self, _ida_graph.new_pointvec_t(*args))
    __swig_destroy__ = _ida_graph.delete_pointvec_t

    def push_back(self, *args) -> "point_t &":
        r"""
        push_back(self, x)
        push_back(self) -> point_t
        """
        return _ida_graph.pointvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_graph.pointvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_graph.pointvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_graph.pointvec_t_empty(self, *args)

    def at(self, *args) -> "point_t const &":
        r"""
        at(self, _idx) -> point_t
        """
        return _ida_graph.pointvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_graph.pointvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_graph.pointvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_graph.pointvec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, x=point_t())
        """
        return _ida_graph.pointvec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_graph.pointvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""
        reserve(self, cnt)
        """
        return _ida_graph.pointvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_graph.pointvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""
        swap(self, r)
        """
        return _ida_graph.pointvec_t_swap(self, *args)

    def extract(self, *args) -> "point_t *":
        r"""
        extract(self) -> point_t
        """
        return _ida_graph.pointvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""
        inject(self, s, len)
        """
        return _ida_graph.pointvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.pointvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.pointvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< point_t >::const_iterator":
        r"""
        begin(self) -> point_t
        begin(self) -> point_t
        """
        return _ida_graph.pointvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< point_t >::const_iterator":
        r"""
        end(self) -> point_t
        end(self) -> point_t
        """
        return _ida_graph.pointvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< point_t >::iterator":
        r"""
        insert(self, it, x) -> point_t
        """
        return _ida_graph.pointvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< point_t >::iterator":
        r"""
        erase(self, it) -> point_t
        erase(self, first, last) -> point_t
        """
        return _ida_graph.pointvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< point_t >::const_iterator":
        r"""
        find(self, x) -> point_t
        find(self, x) -> point_t
        """
        return _ida_graph.pointvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""
        has(self, x) -> bool
        """
        return _ida_graph.pointvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""
        add_unique(self, x) -> bool
        """
        return _ida_graph.pointvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""
        _del(self, x) -> bool
        """
        return _ida_graph.pointvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_graph.pointvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "point_t const &":
        r"""
        __getitem__(self, i) -> point_t
        """
        return _ida_graph.pointvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, i, v)
        """
        return _ida_graph.pointvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register pointvec_t in _ida_graph:
_ida_graph.pointvec_t_swigregister(pointvec_t)

NIF_BG_COLOR = _ida_graph.NIF_BG_COLOR
"""
 'node_info_t::bg_color'
"""

NIF_FRAME_COLOR = _ida_graph.NIF_FRAME_COLOR
"""
 'node_info_t::frame_color'
"""

NIF_EA = _ida_graph.NIF_EA
"""
 'node_info_t::ea'
"""

NIF_TEXT = _ida_graph.NIF_TEXT
"""
 'node_info_t::text'
"""

NIF_FLAGS = _ida_graph.NIF_FLAGS
"""
 'node_info_t::flags'
"""

NIF_ALL = _ida_graph.NIF_ALL

GLICTL_CENTER = _ida_graph.GLICTL_CENTER
"""
the gli should be set/get as center
"""

class node_info_t(object):
    r"""
    Proxy of C++ node_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> node_info_t
        """
        _ida_graph.node_info_t_swiginit(self, _ida_graph.new_node_info_t(*args))
    bg_color = property(_ida_graph.node_info_t_bg_color_get, _ida_graph.node_info_t_bg_color_set)
    frame_color = property(_ida_graph.node_info_t_frame_color_get, _ida_graph.node_info_t_frame_color_set)
    flags = property(_ida_graph.node_info_t_flags_get, _ida_graph.node_info_t_flags_set)
    ea = property(_ida_graph.node_info_t_ea_get, _ida_graph.node_info_t_ea_set)
    text = property(_ida_graph.node_info_t_text_get, _ida_graph.node_info_t_text_set)

    def valid_bg_color(self, *args) -> "bool":
        r"""
        valid_bg_color(self) -> bool
        """
        return _ida_graph.node_info_t_valid_bg_color(self, *args)

    def valid_frame_color(self, *args) -> "bool":
        r"""
        valid_frame_color(self) -> bool
        """
        return _ida_graph.node_info_t_valid_frame_color(self, *args)

    def valid_ea(self, *args) -> "bool":
        r"""
        valid_ea(self) -> bool
        """
        return _ida_graph.node_info_t_valid_ea(self, *args)

    def valid_text(self, *args) -> "bool":
        r"""
        valid_text(self) -> bool
        """
        return _ida_graph.node_info_t_valid_text(self, *args)

    def valid_flags(self, *args) -> "bool":
        r"""
        valid_flags(self) -> bool
        """
        return _ida_graph.node_info_t_valid_flags(self, *args)

    def get_flags_for_valid(self, *args) -> "uint32":
        r"""
        get_flags_for_valid(self) -> uint32
        """
        return _ida_graph.node_info_t_get_flags_for_valid(self, *args)
    __swig_destroy__ = _ida_graph.delete_node_info_t

# Register node_info_t in _ida_graph:
_ida_graph.node_info_t_swigregister(node_info_t)
NIFF_SHOW_CONTENTS = _ida_graph.NIFF_SHOW_CONTENTS



def get_node_info(*args) -> "bool":
    r"""
    get_node_info(out, gid, node) -> bool


    Get node info.
    
    @param out: result (C++: node_info_t  *)
    @param gid: id of desired graph (C++: graph_id_t)
    @param node: node number (C++: int)
    @return: success
    """
    return _ida_graph.get_node_info(*args)

def set_node_info(*args) -> "void":
    r"""
    set_node_info(gid, node, ni, flags)


    Set node info.
    
    @param gid: id of desired graph (C++: graph_id_t)
    @param node: node number (C++: int)
    @param ni: node info to use (C++: const  node_info_t  &)
    @param flags: combination of  Node info flags , identifying which
                  fields of 'ni' will be used (C++: uint32)
    """
    return _ida_graph.set_node_info(*args)

def del_node_info(*args) -> "void":
    r"""
    del_node_info(gid, node)


    Delete the 'node_info_t' for the given node.
    
    
    @param gid (C++: graph_id_t)
    @param node (C++: int)
    """
    return _ida_graph.del_node_info(*args)

def clr_node_info(*args) -> "void":
    r"""
    clr_node_info(gid, node, flags)


    Clear node info for the given node.
    
    @param gid: id of desired graph (C++: graph_id_t)
    @param node: node number (C++: int)
    @param flags: combination of  Node info flags , identifying which
                  fields of  node_info_t  will be cleared (C++: uint32)
    """
    return _ida_graph.clr_node_info(*args)
class node_ordering_t(object):
    r"""
    Proxy of C++ node_ordering_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_graph.node_ordering_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""
        resize(self, n)
        """
        return _ida_graph.node_ordering_t_resize(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_graph.node_ordering_t_size(self, *args)

    def set(self, *args) -> "void":
        r"""
        set(self, _node, num)
        """
        return _ida_graph.node_ordering_t_set(self, *args)

    def node(self, *args) -> "int":
        r"""
        node(self, _order) -> int
        """
        return _ida_graph.node_ordering_t_node(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> node_ordering_t
        """
        _ida_graph.node_ordering_t_swiginit(self, _ida_graph.new_node_ordering_t(*args))
    __swig_destroy__ = _ida_graph.delete_node_ordering_t

# Register node_ordering_t in _ida_graph:
_ida_graph.node_ordering_t_swigregister(node_ordering_t)

class edge_t(object):
    r"""
    Proxy of C++ edge_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    src = property(_ida_graph.edge_t_src_get, _ida_graph.edge_t_src_set)
    dst = property(_ida_graph.edge_t_dst_get, _ida_graph.edge_t_dst_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> edge_t
        __init__(self, x, y) -> edge_t
        """
        _ida_graph.edge_t_swiginit(self, _ida_graph.new_edge_t(*args))

    def __lt__(self, *args) -> "bool":
        r"""
        __lt__(self, y) -> bool
        """
        return _ida_graph.edge_t___lt__(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, y) -> bool
        """
        return _ida_graph.edge_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, y) -> bool
        """
        return _ida_graph.edge_t___ne__(self, *args)
    __swig_destroy__ = _ida_graph.delete_edge_t

# Register edge_t in _ida_graph:
_ida_graph.edge_t_swigregister(edge_t)

edge_error = _ida_graph.edge_error

edge_tree = _ida_graph.edge_tree

edge_forward = _ida_graph.edge_forward

edge_back = _ida_graph.edge_back

edge_cross = _ida_graph.edge_cross

edge_subgraph = _ida_graph.edge_subgraph

class graph_node_visitor_t(object):
    r"""
    Proxy of C++ graph_node_visitor_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def reinit(self, *args) -> "void":
        r"""
        reinit(self)
        """
        return _ida_graph.graph_node_visitor_t_reinit(self, *args)

    def set_visited(self, *args) -> "void":
        r"""
        set_visited(self, n)
        """
        return _ida_graph.graph_node_visitor_t_set_visited(self, *args)

    def is_visited(self, *args) -> "bool":
        r"""
        is_visited(self, n) -> bool
        """
        return _ida_graph.graph_node_visitor_t_is_visited(self, *args)

    def visit_node(self, *args) -> "int":
        r"""
        visit_node(self, arg0) -> int
        """
        return _ida_graph.graph_node_visitor_t_visit_node(self, *args)

    def is_forbidden_edge(self, *args) -> "bool":
        r"""
        is_forbidden_edge(self, arg0, arg1) -> bool
        """
        return _ida_graph.graph_node_visitor_t_is_forbidden_edge(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> graph_node_visitor_t
        """
        if self.__class__ == graph_node_visitor_t:
            _self = None
        else:
            _self = self
        _ida_graph.graph_node_visitor_t_swiginit(self, _ida_graph.new_graph_node_visitor_t(_self, *args))
    __swig_destroy__ = _ida_graph.delete_graph_node_visitor_t
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_graph_node_visitor_t(self)
        return weakref.proxy(self)

# Register graph_node_visitor_t in _ida_graph:
_ida_graph.graph_node_visitor_t_swigregister(graph_node_visitor_t)

class graph_path_visitor_t(object):
    r"""
    Proxy of C++ graph_path_visitor_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_ida_graph.graph_path_visitor_t_path_get, _ida_graph.graph_path_visitor_t_path_set)
    prune = property(_ida_graph.graph_path_visitor_t_prune_get, _ida_graph.graph_path_visitor_t_prune_set)

    def walk_forward(self, *args) -> "int":
        r"""
        walk_forward(self, arg0) -> int
        """
        return _ida_graph.graph_path_visitor_t_walk_forward(self, *args)

    def walk_backward(self, *args) -> "int":
        r"""
        walk_backward(self, arg0) -> int
        """
        return _ida_graph.graph_path_visitor_t_walk_backward(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> graph_path_visitor_t
        """
        if self.__class__ == graph_path_visitor_t:
            _self = None
        else:
            _self = self
        _ida_graph.graph_path_visitor_t_swiginit(self, _ida_graph.new_graph_path_visitor_t(_self, *args))
    __swig_destroy__ = _ida_graph.delete_graph_path_visitor_t
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_graph_path_visitor_t(self)
        return weakref.proxy(self)

# Register graph_path_visitor_t in _ida_graph:
_ida_graph.graph_path_visitor_t_swigregister(graph_path_visitor_t)

class point_t(object):
    r"""
    Proxy of C++ point_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_ida_graph.point_t_x_get, _ida_graph.point_t_x_set)
    y = property(_ida_graph.point_t_y_get, _ida_graph.point_t_y_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> point_t
        __init__(self, _x, _y) -> point_t
        """
        _ida_graph.point_t_swiginit(self, _ida_graph.new_point_t(*args))

    def add(self, *args) -> "point_t &":
        r"""
        add(self, r) -> point_t
        """
        return _ida_graph.point_t_add(self, *args)

    def sub(self, *args) -> "point_t &":
        r"""
        sub(self, r) -> point_t
        """
        return _ida_graph.point_t_sub(self, *args)

    def negate(self, *args) -> "void":
        r"""
        negate(self)
        """
        return _ida_graph.point_t_negate(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.point_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.point_t___ne__(self, *args)
    __swig_destroy__ = _ida_graph.delete_point_t

# Register point_t in _ida_graph:
_ida_graph.point_t_swigregister(point_t)


def calc_dist(*args) -> "double":
    r"""
    calc_dist(p, q) -> double


    Calculate distance between p and q.
    
    
    @param p (C++: point_t)
    @param q (C++: point_t)
    """
    return _ida_graph.calc_dist(*args)
class pointseq_t(pointvec_t):
    r"""
    Proxy of C++ pointseq_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> pointseq_t
        """
        _ida_graph.pointseq_t_swiginit(self, _ida_graph.new_pointseq_t(*args))
    __swig_destroy__ = _ida_graph.delete_pointseq_t

# Register pointseq_t in _ida_graph:
_ida_graph.pointseq_t_swigregister(pointseq_t)

class rect_t(object):
    r"""
    Proxy of C++ rect_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    left = property(_ida_graph.rect_t_left_get, _ida_graph.rect_t_left_set)
    top = property(_ida_graph.rect_t_top_get, _ida_graph.rect_t_top_set)
    right = property(_ida_graph.rect_t_right_get, _ida_graph.rect_t_right_set)
    bottom = property(_ida_graph.rect_t_bottom_get, _ida_graph.rect_t_bottom_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> rect_t
        __init__(self, l, t, r, b) -> rect_t
        __init__(self, p0, p1) -> rect_t
        """
        _ida_graph.rect_t_swiginit(self, _ida_graph.new_rect_t(*args))

    def width(self, *args) -> "int":
        r"""
        width(self) -> int
        """
        return _ida_graph.rect_t_width(self, *args)

    def height(self, *args) -> "int":
        r"""
        height(self) -> int
        """
        return _ida_graph.rect_t_height(self, *args)

    def move_to(self, *args) -> "void":
        r"""
        move_to(self, p)
        """
        return _ida_graph.rect_t_move_to(self, *args)

    def move_by(self, *args) -> "void":
        r"""
        move_by(self, p)
        """
        return _ida_graph.rect_t_move_by(self, *args)

    def center(self, *args) -> "point_t":
        r"""
        center(self) -> point_t
        """
        return _ida_graph.rect_t_center(self, *args)

    def topleft(self, *args) -> "point_t":
        r"""
        topleft(self) -> point_t
        """
        return _ida_graph.rect_t_topleft(self, *args)

    def bottomright(self, *args) -> "point_t":
        r"""
        bottomright(self) -> point_t
        """
        return _ida_graph.rect_t_bottomright(self, *args)

    def grow(self, *args) -> "void":
        r"""
        grow(self, delta)
        """
        return _ida_graph.rect_t_grow(self, *args)

    def intersect(self, *args) -> "void":
        r"""
        intersect(self, r)
        """
        return _ida_graph.rect_t_intersect(self, *args)

    def make_union(self, *args) -> "void":
        r"""
        make_union(self, r)
        """
        return _ida_graph.rect_t_make_union(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_graph.rect_t_empty(self, *args)

    def is_intersection_empty(self, *args) -> "bool":
        r"""
        is_intersection_empty(self, r) -> bool
        """
        return _ida_graph.rect_t_is_intersection_empty(self, *args)

    def contains(self, *args) -> "bool":
        r"""
        contains(self, p) -> bool
        """
        return _ida_graph.rect_t_contains(self, *args)

    def area(self, *args) -> "int":
        r"""
        area(self) -> int
        """
        return _ida_graph.rect_t_area(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.rect_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.rect_t___ne__(self, *args)
    __swig_destroy__ = _ida_graph.delete_rect_t

# Register rect_t in _ida_graph:
_ida_graph.rect_t_swigregister(rect_t)

class TPointDouble(object):
    r"""
    Proxy of C++ TPointDouble class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_ida_graph.TPointDouble_x_get, _ida_graph.TPointDouble_x_set)
    y = property(_ida_graph.TPointDouble_y_get, _ida_graph.TPointDouble_y_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> TPointDouble
        __init__(self, a, b) -> TPointDouble
        __init__(self, r) -> TPointDouble
        """
        _ida_graph.TPointDouble_swiginit(self, _ida_graph.new_TPointDouble(*args))

    def add(self, *args) -> "void":
        r"""
        add(self, r)
        """
        return _ida_graph.TPointDouble_add(self, *args)

    def sub(self, *args) -> "void":
        r"""
        sub(self, r)
        """
        return _ida_graph.TPointDouble_sub(self, *args)

    def negate(self, *args) -> "void":
        r"""
        negate(self)
        """
        return _ida_graph.TPointDouble_negate(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.TPointDouble___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.TPointDouble___ne__(self, *args)
    __swig_destroy__ = _ida_graph.delete_TPointDouble

# Register TPointDouble in _ida_graph:
_ida_graph.TPointDouble_swigregister(TPointDouble)

class edge_info_t(object):
    r"""
    Proxy of C++ edge_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    color = property(_ida_graph.edge_info_t_color_get, _ida_graph.edge_info_t_color_set)
    width = property(_ida_graph.edge_info_t_width_get, _ida_graph.edge_info_t_width_set)
    srcoff = property(_ida_graph.edge_info_t_srcoff_get, _ida_graph.edge_info_t_srcoff_set)
    dstoff = property(_ida_graph.edge_info_t_dstoff_get, _ida_graph.edge_info_t_dstoff_set)
    layout = property(_ida_graph.edge_info_t_layout_get, _ida_graph.edge_info_t_layout_set)

    def reverse_layout(self, *args) -> "void":
        r"""
        reverse_layout(self)
        """
        return _ida_graph.edge_info_t_reverse_layout(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> edge_info_t
        """
        _ida_graph.edge_info_t_swiginit(self, _ida_graph.new_edge_info_t(*args))
    __swig_destroy__ = _ida_graph.delete_edge_info_t

# Register edge_info_t in _ida_graph:
_ida_graph.edge_info_t_swigregister(edge_info_t)
cvar = _ida_graph.cvar
layout_none = cvar.layout_none
layout_digraph = cvar.layout_digraph
layout_tree = cvar.layout_tree
layout_circle = cvar.layout_circle
layout_polar_tree = cvar.layout_polar_tree
layout_orthogonal = cvar.layout_orthogonal
layout_radial_tree = cvar.layout_radial_tree

class edge_layout_point_t(object):
    r"""
    Proxy of C++ edge_layout_point_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pidx = property(_ida_graph.edge_layout_point_t_pidx_get, _ida_graph.edge_layout_point_t_pidx_set)
    e = property(_ida_graph.edge_layout_point_t_e_get, _ida_graph.edge_layout_point_t_e_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> edge_layout_point_t
        __init__(self, r) -> edge_layout_point_t
        __init__(self, _e, _pidx) -> edge_layout_point_t
        """
        _ida_graph.edge_layout_point_t_swiginit(self, _ida_graph.new_edge_layout_point_t(*args))

    def compare(self, *args) -> "int":
        r"""
        compare(self, r) -> int
        """
        return _ida_graph.edge_layout_point_t_compare(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.edge_layout_point_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.edge_layout_point_t___ne__(self, *args)
    __swig_destroy__ = _ida_graph.delete_edge_layout_point_t

# Register edge_layout_point_t in _ida_graph:
_ida_graph.edge_layout_point_t_swigregister(edge_layout_point_t)

class selection_item_t(object):
    r"""
    Proxy of C++ selection_item_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_node = property(_ida_graph.selection_item_t_is_node_get, _ida_graph.selection_item_t_is_node_set)
    node = property(_ida_graph.selection_item_t_node_get, _ida_graph.selection_item_t_node_set)
    elp = property(_ida_graph.selection_item_t_elp_get, _ida_graph.selection_item_t_elp_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> selection_item_t
        __init__(self, n) -> selection_item_t
        __init__(self, _elp) -> selection_item_t
        __init__(self, e, idx) -> selection_item_t
        """
        _ida_graph.selection_item_t_swiginit(self, _ida_graph.new_selection_item_t(*args))

    def compare(self, *args) -> "int":
        r"""
        compare(self, r) -> int
        """
        return _ida_graph.selection_item_t_compare(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.selection_item_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.selection_item_t___ne__(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""
        __lt__(self, r) -> bool
        """
        return _ida_graph.selection_item_t___lt__(self, *args)
    __swig_destroy__ = _ida_graph.delete_selection_item_t

# Register selection_item_t in _ida_graph:
_ida_graph.selection_item_t_swigregister(selection_item_t)

class screen_graph_selection_t(screen_graph_selection_base_t):
    r"""
    Proxy of C++ screen_graph_selection_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def has(self, *args) -> "bool":
        r"""
        has(self, item) -> bool
        """
        return _ida_graph.screen_graph_selection_t_has(self, *args)

    def add(self, *args) -> "void":
        r"""
        add(self, s)
        """
        return _ida_graph.screen_graph_selection_t_add(self, *args)

    def sub(self, *args) -> "void":
        r"""
        sub(self, s)
        """
        return _ida_graph.screen_graph_selection_t_sub(self, *args)

    def add_node(self, *args) -> "void":
        r"""
        add_node(self, node)
        """
        return _ida_graph.screen_graph_selection_t_add_node(self, *args)

    def del_node(self, *args) -> "void":
        r"""
        del_node(self, node)
        """
        return _ida_graph.screen_graph_selection_t_del_node(self, *args)

    def add_point(self, *args) -> "void":
        r"""
        add_point(self, e, idx)
        """
        return _ida_graph.screen_graph_selection_t_add_point(self, *args)

    def del_point(self, *args) -> "void":
        r"""
        del_point(self, e, idx)
        """
        return _ida_graph.screen_graph_selection_t_del_point(self, *args)

    def nodes_count(self, *args) -> "size_t":
        r"""
        nodes_count(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_t_nodes_count(self, *args)

    def points_count(self, *args) -> "size_t":
        r"""
        points_count(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_t_points_count(self, *args)

    def items_count(self, *args) -> "size_t":
        r"""
        items_count(self, look_for_nodes) -> size_t
        """
        return _ida_graph.screen_graph_selection_t_items_count(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> screen_graph_selection_t
        """
        _ida_graph.screen_graph_selection_t_swiginit(self, _ida_graph.new_screen_graph_selection_t(*args))
    __swig_destroy__ = _ida_graph.delete_screen_graph_selection_t

# Register screen_graph_selection_t in _ida_graph:
_ida_graph.screen_graph_selection_t_swigregister(screen_graph_selection_t)

class edge_segment_t(object):
    r"""
    Proxy of C++ edge_segment_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    e = property(_ida_graph.edge_segment_t_e_get, _ida_graph.edge_segment_t_e_set)
    nseg = property(_ida_graph.edge_segment_t_nseg_get, _ida_graph.edge_segment_t_nseg_set)
    x0 = property(_ida_graph.edge_segment_t_x0_get, _ida_graph.edge_segment_t_x0_set)
    x1 = property(_ida_graph.edge_segment_t_x1_get, _ida_graph.edge_segment_t_x1_set)

    def length(self, *args) -> "size_t":
        r"""
        length(self) -> size_t
        """
        return _ida_graph.edge_segment_t_length(self, *args)

    def toright(self, *args) -> "bool":
        r"""
        toright(self) -> bool
        """
        return _ida_graph.edge_segment_t_toright(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""
        __lt__(self, r) -> bool
        """
        return _ida_graph.edge_segment_t___lt__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> edge_segment_t
        """
        _ida_graph.edge_segment_t_swiginit(self, _ida_graph.new_edge_segment_t(*args))
    __swig_destroy__ = _ida_graph.delete_edge_segment_t

# Register edge_segment_t in _ida_graph:
_ida_graph.edge_segment_t_swigregister(edge_segment_t)

git_none = _ida_graph.git_none

git_edge = _ida_graph.git_edge

git_node = _ida_graph.git_node

git_tool = _ida_graph.git_tool

git_text = _ida_graph.git_text

git_elp = _ida_graph.git_elp

class graph_item_t(object):
    r"""
    Proxy of C++ graph_item_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_ida_graph.graph_item_t_type_get, _ida_graph.graph_item_t_type_set)
    e = property(_ida_graph.graph_item_t_e_get, _ida_graph.graph_item_t_e_set)
    n = property(_ida_graph.graph_item_t_n_get, _ida_graph.graph_item_t_n_set)
    b = property(_ida_graph.graph_item_t_b_get, _ida_graph.graph_item_t_b_set)
    p = property(_ida_graph.graph_item_t_p_get, _ida_graph.graph_item_t_p_set)
    elp = property(_ida_graph.graph_item_t_elp_get, _ida_graph.graph_item_t_elp_set)

    def is_node(self, *args) -> "bool":
        r"""
        is_node(self) -> bool
        """
        return _ida_graph.graph_item_t_is_node(self, *args)

    def is_edge(self, *args) -> "bool":
        r"""
        is_edge(self) -> bool
        """
        return _ida_graph.graph_item_t_is_edge(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> graph_item_t
        """
        _ida_graph.graph_item_t_swiginit(self, _ida_graph.new_graph_item_t(*args))
    __swig_destroy__ = _ida_graph.delete_graph_item_t

# Register graph_item_t in _ida_graph:
_ida_graph.graph_item_t_swigregister(graph_item_t)

class interval_t(object):
    r"""
    Proxy of C++ interval_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x0 = property(_ida_graph.interval_t_x0_get, _ida_graph.interval_t_x0_set)
    x1 = property(_ida_graph.interval_t_x1_get, _ida_graph.interval_t_x1_set)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_graph.interval_t_empty(self, *args)

    def intersect(self, *args) -> "void":
        r"""
        intersect(self, r)
        """
        return _ida_graph.interval_t_intersect(self, *args)

    def make_union(self, *args) -> "void":
        r"""
        make_union(self, r)
        """
        return _ida_graph.interval_t_make_union(self, *args)

    def move_by(self, *args) -> "void":
        r"""
        move_by(self, shift)
        """
        return _ida_graph.interval_t_move_by(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> interval_t
        __init__(self, y0, y1) -> interval_t
        __init__(self, s) -> interval_t
        """
        _ida_graph.interval_t_swiginit(self, _ida_graph.new_interval_t(*args))

    def length(self, *args) -> "int":
        r"""
        length(self) -> int
        """
        return _ida_graph.interval_t_length(self, *args)

    def contains(self, *args) -> "bool":
        r"""
        contains(self, x) -> bool
        """
        return _ida_graph.interval_t_contains(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""
        __eq__(self, r) -> bool
        """
        return _ida_graph.interval_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""
        __ne__(self, r) -> bool
        """
        return _ida_graph.interval_t___ne__(self, *args)
    __swig_destroy__ = _ida_graph.delete_interval_t

# Register interval_t in _ida_graph:
_ida_graph.interval_t_swigregister(interval_t)

class row_info_t(object):
    r"""
    Proxy of C++ row_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nodes = property(_ida_graph.row_info_t_nodes_get, _ida_graph.row_info_t_nodes_set)
    top = property(_ida_graph.row_info_t_top_get, _ida_graph.row_info_t_top_set)
    bottom = property(_ida_graph.row_info_t_bottom_get, _ida_graph.row_info_t_bottom_set)

    def height(self, *args) -> "int":
        r"""
        height(self) -> int
        """
        return _ida_graph.row_info_t_height(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> row_info_t
        """
        _ida_graph.row_info_t_swiginit(self, _ida_graph.new_row_info_t(*args))
    __swig_destroy__ = _ida_graph.delete_row_info_t

# Register row_info_t in _ida_graph:
_ida_graph.row_info_t_swigregister(row_info_t)

class edge_infos_wrapper_t(object):
    r"""
    Proxy of C++ edge_infos_wrapper_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_graph.edge_infos_wrapper_t_clear(self, *args)
    ptr = property(_ida_graph.edge_infos_wrapper_t_ptr_get, _ida_graph.edge_infos_wrapper_t_ptr_set)

# Register edge_infos_wrapper_t in _ida_graph:
_ida_graph.edge_infos_wrapper_t_swigregister(edge_infos_wrapper_t)
ygap = cvar.ygap
xgap = cvar.xgap
arrow_height = cvar.arrow_height
arrow_width = cvar.arrow_width

class mutable_graph_t(object):
    r"""
    Proxy of C++ mutable_graph_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    gid = property(_ida_graph.mutable_graph_t_gid_get, _ida_graph.mutable_graph_t_gid_set)
    belongs = property(_ida_graph.mutable_graph_t_belongs_get, _ida_graph.mutable_graph_t_belongs_set)
    node_flags = property(_ida_graph.mutable_graph_t_node_flags_get, _ida_graph.mutable_graph_t_node_flags_set)
    org_succs = property(_ida_graph.mutable_graph_t_org_succs_get, _ida_graph.mutable_graph_t_org_succs_set)
    org_preds = property(_ida_graph.mutable_graph_t_org_preds_get, _ida_graph.mutable_graph_t_org_preds_set)
    succs = property(_ida_graph.mutable_graph_t_succs_get, _ida_graph.mutable_graph_t_succs_set)
    preds = property(_ida_graph.mutable_graph_t_preds_get, _ida_graph.mutable_graph_t_preds_set)
    nodes = property(_ida_graph.mutable_graph_t_nodes_get, _ida_graph.mutable_graph_t_nodes_set)
    edges = property(_ida_graph.mutable_graph_t_edges_get, _ida_graph.mutable_graph_t_edges_set)

    def size(self, *args) -> "int":
        r"""
        size(self) -> int
        """
        return _ida_graph.mutable_graph_t_size(self, *args)

    def node_qty(self, *args) -> "int":
        r"""
        node_qty(self) -> int
        """
        return _ida_graph.mutable_graph_t_node_qty(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_graph.mutable_graph_t_clear(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_graph.mutable_graph_t_empty(self, *args)

    def exists(self, *args) -> "bool":
        r"""
        exists(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_exists(self, *args)

    def get_node_representative(self, *args) -> "int":
        r"""
        get_node_representative(self, node) -> int
        """
        return _ida_graph.mutable_graph_t_get_node_representative(self, *args)

    def get_node_group(self, *args) -> "int":
        r"""
        get_node_group(self, node) -> int
        """
        return _ida_graph.mutable_graph_t_get_node_group(self, *args)

    def set_node_group(self, *args) -> "void":
        r"""
        set_node_group(self, node, group)
        """
        return _ida_graph.mutable_graph_t_set_node_group(self, *args)

    def is_deleted_node(self, *args) -> "bool":
        r"""
        is_deleted_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_deleted_node(self, *args)

    def set_deleted_node(self, *args) -> "void":
        r"""
        set_deleted_node(self, node)
        """
        return _ida_graph.mutable_graph_t_set_deleted_node(self, *args)

    def is_subgraph_node(self, *args) -> "bool":
        r"""
        is_subgraph_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_subgraph_node(self, *args)

    def is_dot_node(self, *args) -> "bool":
        r"""
        is_dot_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_dot_node(self, *args)

    def is_group_node(self, *args) -> "bool":
        r"""
        is_group_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_group_node(self, *args)

    def is_displayable_node(self, *args) -> "bool":
        r"""
        is_displayable_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_displayable_node(self, *args)

    def is_simple_node(self, *args) -> "bool":
        r"""
        is_simple_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_simple_node(self, *args)

    def is_collapsed_node(self, *args) -> "bool":
        r"""
        is_collapsed_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_collapsed_node(self, *args)

    def is_uncollapsed_node(self, *args) -> "bool":
        r"""
        is_uncollapsed_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_uncollapsed_node(self, *args)

    def is_visible_node(self, *args) -> "bool":
        r"""
        is_visible_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_visible_node(self, *args)

    def get_first_subgraph_node(self, *args) -> "int":
        r"""
        get_first_subgraph_node(self, group) -> int
        """
        return _ida_graph.mutable_graph_t_get_first_subgraph_node(self, *args)

    def get_next_subgraph_node(self, *args) -> "int":
        r"""
        get_next_subgraph_node(self, group, current) -> int
        """
        return _ida_graph.mutable_graph_t_get_next_subgraph_node(self, *args)

    def create_group(self, *args) -> "int":
        r"""
        create_group(self, nodes) -> int
        """
        return _ida_graph.mutable_graph_t_create_group(self, *args)

    def delete_group(self, *args) -> "bool":
        r"""
        delete_group(self, group) -> bool
        """
        return _ida_graph.mutable_graph_t_delete_group(self, *args)

    def change_group_visibility(self, *args) -> "bool":
        r"""
        change_group_visibility(self, group, expand) -> bool
        """
        return _ida_graph.mutable_graph_t_change_group_visibility(self, *args)

    def nsucc(self, *args) -> "int":
        r"""
        nsucc(self, b) -> int
        """
        return _ida_graph.mutable_graph_t_nsucc(self, *args)

    def npred(self, *args) -> "int":
        r"""
        npred(self, b) -> int
        """
        return _ida_graph.mutable_graph_t_npred(self, *args)

    def succ(self, *args) -> "int":
        r"""
        succ(self, b, i) -> int
        """
        return _ida_graph.mutable_graph_t_succ(self, *args)

    def pred(self, *args) -> "int":
        r"""
        pred(self, b, i) -> int
        """
        return _ida_graph.mutable_graph_t_pred(self, *args)

    def succset(self, *args) -> "intvec_t const &":
        r"""
        succset(self, b) -> intvec_t const &
        """
        return _ida_graph.mutable_graph_t_succset(self, *args)

    def predset(self, *args) -> "intvec_t const &":
        r"""
        predset(self, b) -> intvec_t const &
        """
        return _ida_graph.mutable_graph_t_predset(self, *args)

    def reset(self, *args) -> "void":
        r"""
        reset(self)
        """
        return _ida_graph.mutable_graph_t_reset(self, *args)

    def nrect(self, *args) -> "rect_t &":
        r"""
        nrect(self, n) -> rect_t
        nrect(self, n) -> rect_t
        """
        return _ida_graph.mutable_graph_t_nrect(self, *args)

    def set_edge(self, *args) -> "bool":
        r"""
        set_edge(self, e, ei) -> bool
        """
        return _ida_graph.mutable_graph_t_set_edge(self, *args)

    def create_digraph_layout(self, *args) -> "bool":
        r"""
        create_digraph_layout(self) -> bool
        """
        return _ida_graph.mutable_graph_t_create_digraph_layout(self, *args)

    def del_custom_layout(self, *args) -> "void":
        r"""
        del_custom_layout(self)
        """
        return _ida_graph.mutable_graph_t_del_custom_layout(self, *args)

    def get_custom_layout(self, *args) -> "bool":
        r"""
        get_custom_layout(self) -> bool
        """
        return _ida_graph.mutable_graph_t_get_custom_layout(self, *args)

    def set_custom_layout(self, *args) -> "void":
        r"""
        set_custom_layout(self)
        """
        return _ida_graph.mutable_graph_t_set_custom_layout(self, *args)

    def get_graph_groups(self, *args) -> "bool":
        r"""
        get_graph_groups(self) -> bool
        """
        return _ida_graph.mutable_graph_t_get_graph_groups(self, *args)

    def set_graph_groups(self, *args) -> "void":
        r"""
        set_graph_groups(self)
        """
        return _ida_graph.mutable_graph_t_set_graph_groups(self, *args)

    def calc_group_ea(self, *args) -> "ea_t":
        r"""
        calc_group_ea(self, arg0) -> ea_t
        """
        return _ida_graph.mutable_graph_t_calc_group_ea(self, *args)

    def is_user_graph(self, *args) -> "bool":
        r"""
        is_user_graph(self) -> bool
        """
        return _ida_graph.mutable_graph_t_is_user_graph(self, *args)

    def get_edge(self, *args) -> "edge_info_t":
        r"""
        get_edge(self, e) -> edge_info_t
        """
        return _ida_graph.mutable_graph_t_get_edge(self, *args)
    __swig_destroy__ = _ida_graph.delete_mutable_graph_t
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_mutable_graph_t(self)
        return weakref.proxy(self)

# Register mutable_graph_t in _ida_graph:
_ida_graph.mutable_graph_t_swigregister(mutable_graph_t)
MTG_GROUP_NODE = _ida_graph.MTG_GROUP_NODE
"""
is group node?
"""

MTG_DOT_NODE = _ida_graph.MTG_DOT_NODE
"""
is dot node?
"""

MTG_NON_DISPLAYABLE_NODE = _ida_graph.MTG_NON_DISPLAYABLE_NODE
"""
for disassembly graphs - non-displayable nodes have a visible area
that is too large to generate disassembly lines for without IDA
slowing down significantly (see MAX_VISIBLE_NODE_AREA)
"""

COLLAPSED_NODE = _ida_graph.COLLAPSED_NODE


class graph_visitor_t(object):
    r"""
    Proxy of C++ graph_visitor_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def visit_node(self, *args) -> "int":
        r"""
        visit_node(self, arg2, arg3) -> int
        """
        return _ida_graph.graph_visitor_t_visit_node(self, *args)

    def visit_edge(self, *args) -> "int":
        r"""
        visit_edge(self, arg2, arg3) -> int
        """
        return _ida_graph.graph_visitor_t_visit_edge(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> graph_visitor_t
        """
        if self.__class__ == graph_visitor_t:
            _self = None
        else:
            _self = self
        _ida_graph.graph_visitor_t_swiginit(self, _ida_graph.new_graph_visitor_t(_self, *args))
    __swig_destroy__ = _ida_graph.delete_graph_visitor_t
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_graph_visitor_t(self)
        return weakref.proxy(self)

# Register graph_visitor_t in _ida_graph:
_ida_graph.graph_visitor_t_swigregister(graph_visitor_t)

grcode_calculating_layout = _ida_graph.grcode_calculating_layout

grcode_layout_calculated = _ida_graph.grcode_layout_calculated

grcode_changed_graph = _ida_graph.grcode_changed_graph

grcode_reserved = _ida_graph.grcode_reserved

grcode_clicked = _ida_graph.grcode_clicked

grcode_dblclicked = _ida_graph.grcode_dblclicked

grcode_creating_group = _ida_graph.grcode_creating_group

grcode_deleting_group = _ida_graph.grcode_deleting_group

grcode_group_visibility = _ida_graph.grcode_group_visibility

grcode_gotfocus = _ida_graph.grcode_gotfocus

grcode_lostfocus = _ida_graph.grcode_lostfocus

grcode_user_refresh = _ida_graph.grcode_user_refresh

grcode_user_gentext = _ida_graph.grcode_user_gentext

grcode_user_text = _ida_graph.grcode_user_text

grcode_user_size = _ida_graph.grcode_user_size

grcode_user_title = _ida_graph.grcode_user_title

grcode_user_draw = _ida_graph.grcode_user_draw

grcode_user_hint = _ida_graph.grcode_user_hint

grcode_destroyed = _ida_graph.grcode_destroyed

grcode_create_graph_viewer = _ida_graph.grcode_create_graph_viewer

grcode_get_graph_viewer = _ida_graph.grcode_get_graph_viewer

grcode_get_viewer_graph = _ida_graph.grcode_get_viewer_graph

grcode_create_mutable_graph = _ida_graph.grcode_create_mutable_graph

grcode_set_viewer_graph = _ida_graph.grcode_set_viewer_graph

grcode_refresh_viewer = _ida_graph.grcode_refresh_viewer

grcode_fit_window = _ida_graph.grcode_fit_window

grcode_get_curnode = _ida_graph.grcode_get_curnode

grcode_center_on = _ida_graph.grcode_center_on

grcode_get_selection = _ida_graph.grcode_get_selection

grcode_del_custom_layout = _ida_graph.grcode_del_custom_layout

grcode_set_custom_layout = _ida_graph.grcode_set_custom_layout

grcode_set_graph_groups = _ida_graph.grcode_set_graph_groups

grcode_clear = _ida_graph.grcode_clear

grcode_create_digraph_layout = _ida_graph.grcode_create_digraph_layout

grcode_create_tree_layout = _ida_graph.grcode_create_tree_layout

grcode_create_circle_layout = _ida_graph.grcode_create_circle_layout

grcode_get_node_representative = _ida_graph.grcode_get_node_representative

grcode_find_subgraph_node = _ida_graph.grcode_find_subgraph_node

grcode_create_group = _ida_graph.grcode_create_group

grcode_get_custom_layout = _ida_graph.grcode_get_custom_layout

grcode_get_graph_groups = _ida_graph.grcode_get_graph_groups

grcode_empty = _ida_graph.grcode_empty

grcode_is_visible_node = _ida_graph.grcode_is_visible_node

grcode_delete_group = _ida_graph.grcode_delete_group

grcode_change_group_visibility = _ida_graph.grcode_change_group_visibility

grcode_set_edge = _ida_graph.grcode_set_edge

grcode_node_qty = _ida_graph.grcode_node_qty

grcode_nrect = _ida_graph.grcode_nrect

grcode_set_titlebar_height = _ida_graph.grcode_set_titlebar_height

grcode_create_user_graph_place = _ida_graph.grcode_create_user_graph_place

grcode_create_disasm_graph1 = _ida_graph.grcode_create_disasm_graph1

grcode_create_disasm_graph2 = _ida_graph.grcode_create_disasm_graph2

grcode_set_node_info = _ida_graph.grcode_set_node_info

grcode_get_node_info = _ida_graph.grcode_get_node_info

grcode_del_node_info = _ida_graph.grcode_del_node_info

grcode_viewer_create_groups = _ida_graph.grcode_viewer_create_groups

grcode_viewer_delete_groups = _ida_graph.grcode_viewer_delete_groups

grcode_viewer_groups_visibility = _ida_graph.grcode_viewer_groups_visibility

grcode_viewer_create_groups_vec = _ida_graph.grcode_viewer_create_groups_vec

grcode_viewer_delete_groups_vec = _ida_graph.grcode_viewer_delete_groups_vec

grcode_viewer_groups_visibility_vec = _ida_graph.grcode_viewer_groups_visibility_vec

grcode_delete_mutable_graph = _ida_graph.grcode_delete_mutable_graph

grcode_edge_infos_wrapper_copy = _ida_graph.grcode_edge_infos_wrapper_copy

grcode_edge_infos_wrapper_clear = _ida_graph.grcode_edge_infos_wrapper_clear

grcode_attach_menu_item = _ida_graph.grcode_attach_menu_item

grcode_set_gli = _ida_graph.grcode_set_gli

grcode_get_gli = _ida_graph.grcode_get_gli

class group_crinfo_t(object):
    r"""
    Proxy of C++ group_crinfo_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nodes = property(_ida_graph.group_crinfo_t_nodes_get, _ida_graph.group_crinfo_t_nodes_set)
    text = property(_ida_graph.group_crinfo_t_text_get, _ida_graph.group_crinfo_t_text_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> group_crinfo_t
        """
        _ida_graph.group_crinfo_t_swiginit(self, _ida_graph.new_group_crinfo_t(*args))
    __swig_destroy__ = _ida_graph.delete_group_crinfo_t

# Register group_crinfo_t in _ida_graph:
_ida_graph.group_crinfo_t_swigregister(group_crinfo_t)


def create_graph_viewer(*args) -> "graph_viewer_t *":
    r"""
    create_graph_viewer(title, id, callback, ud, title_height, parent=None) -> graph_viewer_t *


    Create a custom graph viewer.
    
    @param title: the widget title (C++: const char *)
    @param id: graph id (C++: uval_t)
    @param callback: callback to handle graph notifications (
                     graph_notification_t ) (C++: hook_cb_t  *)
    @param ud: user data passed to callback (C++: void *)
    @param title_height: node title height (C++: int)
    @param parent (C++: TWidget *)
    @return: new viewer
    """
    return _ida_graph.create_graph_viewer(*args)

def get_graph_viewer(*args) -> "graph_viewer_t *":
    r"""
    get_graph_viewer(parent) -> graph_viewer_t *


    Get custom graph viewer for given form.
    
    
    @param parent (C++: TWidget *)
    """
    return _ida_graph.get_graph_viewer(*args)

def create_mutable_graph(*args) -> "mutable_graph_t *":
    r"""
    create_mutable_graph(id) -> mutable_graph_t


    Create a new empty graph with given id.
    
    
    @param id (C++: uval_t)
    """
    return _ida_graph.create_mutable_graph(*args)

def create_disasm_graph(*args) -> "mutable_graph_t *":
    r"""
    create_disasm_graph(ea) -> mutable_graph_t
    create_disasm_graph(ranges) -> mutable_graph_t


    Create a graph for the function that contains 'ea'.
    
    
    @param ea (C++: ea_t)
    """
    return _ida_graph.create_disasm_graph(*args)

def get_viewer_graph(*args) -> "mutable_graph_t *":
    r"""
    get_viewer_graph(gv) -> mutable_graph_t


    Get graph object for given custom graph viewer.
    
    
    @param gv (C++: graph_viewer_t  *)
    """
    return _ida_graph.get_viewer_graph(*args)

def set_viewer_graph(*args) -> "void":
    r"""
    set_viewer_graph(gv, g)


    Set the underlying graph object for the given viewer.
    
    
    @param gv (C++: graph_viewer_t  *)
    @param g (C++: mutable_graph_t  *)
    """
    return _ida_graph.set_viewer_graph(*args)

def refresh_viewer(*args) -> "void":
    r"""
    refresh_viewer(gv)


    Redraw the graph in the given view.
    
    
    @param gv (C++: graph_viewer_t  *)
    """
    return _ida_graph.refresh_viewer(*args)

def viewer_fit_window(*args) -> "void":
    r"""
    viewer_fit_window(gv)


    Fit graph viewer to its parent form.
    
    
    @param gv (C++: graph_viewer_t  *)
    """
    return _ida_graph.viewer_fit_window(*args)

def viewer_get_curnode(*args) -> "int":
    r"""
    viewer_get_curnode(gv) -> int


    Get number of currently selected node (-1 if none)
    
    
    @param gv (C++: graph_viewer_t  *)
    """
    return _ida_graph.viewer_get_curnode(*args)

def viewer_center_on(*args) -> "void":
    r"""
    viewer_center_on(gv, node)


    Center the graph view on the given node.
    
    
    @param gv (C++: graph_viewer_t  *)
    @param node (C++: int)
    """
    return _ida_graph.viewer_center_on(*args)

def viewer_set_gli(*args) -> "void":
    r"""
    viewer_set_gli(gv, gli, flags=0)


    Set location info for given graph view If flags contains
    GLICTL_CENTER, then the gli will be set to be the center of the view.
    Otherwise it will be the top-left.
    
    @param gv (C++: graph_viewer_t  *)
    @param gli (C++: const  graph_location_info_t  *)
    @param flags (C++: uint32)
    """
    return _ida_graph.viewer_set_gli(*args)

def viewer_get_gli(*args) -> "bool":
    r"""
    viewer_get_gli(out, gv, flags=0) -> bool


    Get location info for given graph view If flags contains
    GLICTL_CENTER, then the gli that will be retrieved, will be the one at
    the center of the view. Otherwise it will be the top-left.
    
    @param out (C++: graph_location_info_t  *)
    @param gv (C++: graph_viewer_t  *)
    @param flags (C++: uint32)
    """
    return _ida_graph.viewer_get_gli(*args)

def viewer_set_node_info(*args) -> "void":
    r"""
    viewer_set_node_info(gv, n, ni, flags)


    Set node info for node in given viewer (see 'set_node_info()' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param n (C++: int)
    @param ni (C++: const  node_info_t  &)
    @param flags (C++: uint32)
    """
    return _ida_graph.viewer_set_node_info(*args)

def viewer_get_node_info(*args) -> "bool":
    r"""
    viewer_get_node_info(gv, out, n) -> bool


    Get node info for node in given viewer (see 'get_node_info()' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param out (C++: node_info_t  *)
    @param n (C++: int)
    """
    return _ida_graph.viewer_get_node_info(*args)

def viewer_del_node_info(*args) -> "void":
    r"""
    viewer_del_node_info(gv, n)


    Delete node info for node in given viewer (see 'del_node_info()' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param n (C++: int)
    """
    return _ida_graph.viewer_del_node_info(*args)

def viewer_create_groups(*args) -> "bool":
    r"""
    viewer_create_groups(gv, out_group_nodes, gi) -> bool


    This will perform an operation similar to what happens when a user
    manually selects a set of nodes, right-clicks and selects "Create
    group". This is a wrapper around mutable_graph_t::create_group that
    will, in essence:clone the current graphfor each 'group_crinfo_t' ,
    attempt creating group in that new graphif all were successful,
    animate to that new graph.this accepts parameters that allow creating
    of multiple groups at once; which means only one graph animation will
    be triggered.
    
    @param gv (C++: graph_viewer_t  *)
    @param out_group_nodes (C++: intvec_t  *)
    @param gi (C++: const  groups_crinfos_t  &)
    """
    return _ida_graph.viewer_create_groups(*args)

def viewer_delete_groups(*args) -> "bool":
    r"""
    viewer_delete_groups(gv, groups, new_current=-1) -> bool


    Wrapper around mutable_graph_t::delete_group. This function will:clone
    the current graphattempt deleting the groups in that new graphif
    successful, animate to that new graph.
    
    @param gv (C++: graph_viewer_t  *)
    @param groups (C++: const  intvec_t  &)
    @param new_current (C++: int)
    """
    return _ida_graph.viewer_delete_groups(*args)

def viewer_set_groups_visibility(*args) -> "bool":
    r"""
    viewer_set_groups_visibility(gv, groups, expand, new_current=-1) -> bool


    Wrapper around mutable_graph_t::change_visibility. This function
    will:clone the current graphattempt changing visibility of the groups
    in that new graphif successful, animate to that new graph.
    
    @param gv (C++: graph_viewer_t  *)
    @param groups (C++: const  intvec_t  &)
    @param expand (C++: bool)
    @param new_current (C++: int)
    """
    return _ida_graph.viewer_set_groups_visibility(*args)

def viewer_attach_menu_item(*args) -> "bool":
    r"""
    viewer_attach_menu_item(g, name) -> bool


    Attach a previously-registered action to the view's context menu. See
    'kernwin.hpp' for how to register actions.
    
    @param g (C++: graph_viewer_t  *)
    @param name: action name (C++: const char *)
    @return: success
    """
    return _ida_graph.viewer_attach_menu_item(*args)

def viewer_get_selection(*args) -> "bool":
    r"""
    viewer_get_selection(gv, sgs) -> bool


    Get currently selected items for graph viewer.
    
    
    @param gv (C++: graph_viewer_t  *)
    @param sgs (C++: screen_graph_selection_t  *)
    """
    return _ida_graph.viewer_get_selection(*args)

def viewer_set_titlebar_height(*args) -> "int":
    r"""
    viewer_set_titlebar_height(gv, height) -> int


    Set height of node title bars ( 'grcode_set_titlebar_height' )
    
    
    @param gv (C++: graph_viewer_t  *)
    @param height (C++: int)
    """
    return _ida_graph.viewer_set_titlebar_height(*args)

def delete_mutable_graph(*args) -> "void":
    r"""
    delete_mutable_graph(g)


    Delete graph object.use this only if you are dealing with
    'mutable_graph_t' instances that have not been used together with a
    'graph_viewer_t' . If you have called 'set_viewer_graph()' with your
    graph, the graph's lifecycle will be managed by the viewer, and you
    shouldn't interfere with it
    
    @param g (C++: mutable_graph_t  *)
    """
    return _ida_graph.delete_mutable_graph(*args)
class user_graph_place_t(object):
    r"""
    Proxy of C++ user_graph_place_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    node = property(_ida_graph.user_graph_place_t_node_get, _ida_graph.user_graph_place_t_node_set)
    __swig_destroy__ = _ida_graph.delete_user_graph_place_t

# Register user_graph_place_t in _ida_graph:
_ida_graph.user_graph_place_t_swigregister(user_graph_place_t)


def create_user_graph_place(*args) -> "user_graph_place_t *":
    r"""
    create_user_graph_place(node, lnnum) -> user_graph_place_t


    Get a copy of a 'user_graph_place_t' (returns a pointer to static
    storage)
    
    
    @param node (C++: int)
    @param lnnum (C++: int)
    """
    return _ida_graph.create_user_graph_place(*args)

def pyg_close(*args) -> "void":
    r"""
    pyg_close(_self)
    """
    return _ida_graph.pyg_close(*args)

def pyg_select_node(*args) -> "void":
    r"""
    pyg_select_node(_self, nid)
    """
    return _ida_graph.pyg_select_node(*args)

def pyg_show(*args) -> "bool":
    r"""
    pyg_show(_self) -> bool
    """
    return _ida_graph.pyg_show(*args)

#<pycode(py_graph)>
import ida_idaapi
import ida_kernwin

class GraphViewer(ida_kernwin.CustomIDAMemo):
    class UI_Hooks_Trampoline(ida_kernwin.UI_Hooks):
        def __init__(self, v):
            ida_kernwin.UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, w, popup_handle):
            my_w = self.v().GetWidget()
            if w == my_w:
                self.v().OnPopup(my_w, popup_handle)

    """
    This class wraps the user graphing facility provided by the graph.hpp file
    """
    def __init__(self, title, close_open = False):
        """
        Constructs the GraphView object.
        Please do not remove or rename the private fields

        @param title: The title of the graph window
        @param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?
        """
        self._title = title
        self._nodes = []
        self._edges = []
        self._close_open = close_open
        def _qccb(ctx, cmd_id):
            return self.OnCommand(cmd_id)
        self._quick_commands = ida_kernwin.quick_widget_commands_t(_qccb)
        ida_kernwin.CustomIDAMemo.__init__(self)
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)

    def AddNode(self, obj):
        """
        Creates a node associated with the given object and returns the node id
        """
        id = len(self._nodes)
        self._nodes.append(obj)
        return id

    def AddEdge(self, src_node, dest_node):
        """
        Creates an edge between two given node ids
        """
        assert src_node < len(self._nodes), "Source node %d is out of bounds" % src_node
        assert dest_node < len(self._nodes), "Destination node %d is out of bounds" % dest_node
        self._edges.append( (src_node, dest_node) )

    def Clear(self):
        """
        Clears all the nodes and edges
        """
        self._nodes = []
        self._edges = []

    def __iter__(self):
        return (self._nodes[index] for index in range(0, len(self._nodes)))

    def __getitem__(self, idx):
        """
        Returns a reference to the object associated with this node id
        """
        if idx >= len(self._nodes):
            raise KeyError
        else:
            return self._nodes[idx]

    def Count(self):
        """
        Returns the node count
        """
        return len(self._nodes)

    def Close(self):
        """
        Closes the graph.
        It is possible to call Show() again (which will recreate the graph)
        """
        _ida_graph.pyg_close(self)

    def Show(self):
        """
        Shows an existing graph or creates a new one

        @return: Boolean
        """
        if self._close_open:
            import ida_kernwin
            frm = ida_kernwin.find_widget(self._title)
            if frm:
                ida_kernwin.close_widget(frm, 0)
        return _ida_graph.pyg_show(self)

    def Select(self, node_id):
        """
        Selects a node on the graph
        """
        _ida_graph.pyg_select_node(self, node_id)

    def OnRefresh(self):
        """
        Event called when the graph is refreshed or first created.
        From this event you are supposed to create nodes and edges.
        This callback is mandatory.

        @note: ***It is important to clear previous nodes before adding nodes.***
        @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
        """
        self.Clear()

        return True

    def AddCommand(self, title, shortcut):
        return self._quick_commands.add(
            caption=title,
            flags=ida_kernwin.CHOOSER_POPUP_MENU,
            menu_index=-1,
            icon=-1,
            emb=None,
            shortcut=shortcut)

    def OnPopup(self, widget, popup_handle):
        self._quick_commands.populate_popup(widget, popup_handle)

    def OnCommand(self, cmd_id):
        return 0


#<pydoc>
#    def OnGetText(self, node_id):
#        """
#        Triggered when the graph viewer wants the text and color for a given node.
#        This callback is triggered one time for a given node (the value will be cached and used later without calling Python).
#        When you call refresh then again this callback will be called for each node.
#
#        This callback is mandatory.
#
#        @return: Return a string to describe the node text or return a tuple (node_text, node_color) to describe both text and color
#        """
#        return str(self[node_id])
#
#    def OnActivate(self):
#        """
#        Triggered when the graph window gets the focus
#        @return: None
#        """
#        print("Activated....")
#
#    def OnDeactivate(self):
#        """Triggered when the graph window loses the focus
#        @return: None
#        """
#        print("Deactivated....")
#
#    def OnHint(self, node_id):
#        """
#        Triggered when the graph viewer wants to retrieve hint text associated with a given node
#
#        @return: None if no hint is avail or a string designating the hint
#        """
#        return "hint for " + str(node_id)
#
#    def OnEdgeHint(self, src, dst):
#        """
#        Triggered when the graph viewer wants to retrieve hint text associated with a edge
#
#        @return: None if no hint is avail or a string designating the hint
#        """
#        return "hint for edge %d -> %d" % (src, dst)
#
#    def OnClose(self):
#        """Triggered when the graph viewer window is being closed
#        @return: None
#        """
#        print("Closing.......")
#
#    def OnClick(self, node_id):
#        """
#        Triggered when a node is clicked
#        @return: False to ignore the click and True otherwise
#        """
#        print("clicked on", self[node_id])
#        return True
#
#    def OnDblClick(self, node_id):
#        """
#        Triggerd when a node is double-clicked.
#        @return: False to ignore the click and True otherwise
#        """
#        print("dblclicked on", self[node_id])
#        return True
#</pydoc>
#</pycode(py_graph)>


if _BC695:
    clr_node_info2=clr_node_info
    del_node_info2=del_node_info
    get_node_info2=get_node_info
    set_node_info2=set_node_info
    GraphViewer.GetTForm = GraphViewer.GetWidget



